import React, { useState, useEffect, createContext, useContext, useCallback, useMemo, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import {
  getAuth,
  signInWithCustomToken,
  onAuthStateChanged,
  GoogleAuthProvider,
  signInWithPopup,
  signOut
} from 'firebase/auth';
import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, deleteDoc, onSnapshot, query, where, serverTimestamp } from 'firebase/firestore';
import { PieChart, Pie, Cell, Tooltip, Legend, ResponsiveContainer } from 'recharts';

// Contexto de Autenticação para compartilhar o estado do usuário entre componentes
const AuthContext = createContext(null);

/**
 * Função auxiliar para formatar um timestamp do Firestore ou uma data comum.
 * @param {firebase.firestore.Timestamp | Date | null} timestamp - O timestamp a ser formatado.
 * @returns {string} A data formatada ou 'Nunca' se o timestamp for nulo.
 */
const formatDate = (timestamp) => {
  if (!timestamp) return 'Nunca';
  const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
  return date.toLocaleDateString('pt-BR', { year: 'numeric', month: 'long', day: 'numeric' });
};

// Variáveis globais fornecidas pelo ambiente Canvas
// Em um ambiente de produção, estas seriam carregadas de forma segura.
const canvasAppId = typeof __app_id !== 'undefined' ? __app_id : null;
const canvasFirebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_firebase_config) : null;
const canvasInitialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Configuração do Firebase para ambiente LOCAL (APENAS PARA DESENVOLVIMENTO LOCAL)
// SUBSTITUA COM SEUS DADOS REAIS DO CONSOLE DO FIREBASE PARA PRODUÇÃO
const localFirebaseConfig = {
  apiKey: "AIzaSyC0ds__MgUNjL7k3mSAx--B_kKaXU40ato", // SUBSTITUA PELA SUA API KEY REAL
  authDomain: "medical-flashcards-app.firebaseapp.com", // SUBSTITUA PELO SEU AUTH DOMAIN REAL
  projectId: "medical-flashcards-app", // SUBSTITUA PELO SEU PROJECT ID REAL
  storageBucket: "medical-flashcards-app.firebase-storage.app", // SUBSTITUA PELO SEU STORAGE BUCKET REAL
  messagingSenderId: "243887661825", // SUBSTITUA PELO SEU MESSAGING SENDER ID REAL
  appId: "1:243887661825:web:53de03159c7b0c22b17100", // SUBSTITUA PELO SEU APP ID REAL
  // measurementId: "G-N3RBYE0536" // Opcional, se você não usa Analytics, pode remover
};

// Determina qual configuração do Firebase usar: a do ambiente Canvas ou a local de desenvolvimento.
const currentFirebaseConfig = canvasFirebaseConfig || localFirebaseConfig;
const currentAppId = canvasAppId || localFirebaseConfig.projectId; // Usa projectId como fallback para appId local
const currentInitialAuthToken = canvasInitialAuthToken; // Token inicial é específico do Canvas

// Constantes para Áreas e Especialidades Médicas (compartilhadas entre componentes)
// Estas são usadas para categorizar as questões de residência.
const AREAS_AND_SPECIALTIES = {
  'Cirurgia': ['Cirurgia do Trauma', 'Cirurgia Geral', 'Especialidades Cirúrgicas', 'Gastroenterologia'],
  'Clínica Médica': ['Cardiologia', 'Endocrinologia', 'Hematologia', 'Infectologia', 'Medicina Intensiva', 'Nefrologia', 'Neurologia', 'Pneumologia', 'Psiquiatria', 'Reumatologia'],
  'Pediatria': ['Cirurgia Pediátrica', 'Clínica Neonatal', 'Crescimento e Desenvolvimento na Infância', 'Endocrinologia', 'Geral', 'Hematologia', 'Nefrologia', 'Reumatologia', 'Síndromes Respiratórias na Infância'],
  'Ginecologia e Obstetrícia': ['Ginecologia e Obstetrícia'],
  'Preventiva': [
    'Análise de Métodos Diagnósticos', 'Bioestatística Aplicada à Análise de Estudos Epidemiológicos',
    'Causalidade em Epidemiologia', 'Conceitos Básicos e Definições',
    'Dinâmica de Transmissão e Distribuição Temporal das Doenças', 'Estudos Epidemiológicos',
    'Ética Médica', 'Humanização de Atendimento Médico', 'Indicadores', 'Infectologia',
    'Medicina Baseada em Evidências', 'Medicina do Trabalho', 'Medicina Legal',
    'Método Clínico Centrado na Pessoa', 'Política de Saúde no Brasil', 'Saúde do Idoso',
    'Semiologia', 'Sistema de Saúde Suplementar (ANS)', 'Transição Epidemiológica e Demográfica',
    'Vigilância Epidemiológica'
  ],
};


/**
 * Componente principal da aplicação Flashcards Médicos.
 * Gerencia o estado global, autenticação, navegação e dados do Firestore.
 */
function App() {
  // Estados relacionados à autenticação do usuário
  const [user, setUser] = useState(null);
  const [loadingAuth, setLoadingAuth] = useState(true); // Indica se a autenticação está em andamento
  const [auth, setAuth] = useState(null); // Instância do Firebase Auth
  const [userId, setUserId] = useState(null); // UID do usuário logado
  const [authChecked, setAuthChecked] = useState(false); // Indica se a verificação inicial de autenticação foi concluída

  // Estados relacionados ao Firestore e funcionalidades do aplicativo
  const [db, setDb] = useState(null); // Instância do Firestore
  const [userFlashcards, setUserFlashcards] = useState([]); // Lista de flashcards simples do usuário
  const [residencyQuestions, setResidencyQuestions] = useState([]); // Lista de questões de residência públicas
  const [currentView, setCurrentView] = useState('list'); // Gerencia a view atual (lista, adicionar, revisar, etc.)
  const [editingFlashcard, setEditingFlashcard] = useState(null); // Flashcard sendo editado
  const [searchTerm, setSearchTerm] = useState(''); // Termo de busca para flashcards
  const [filterDiscipline, setFilterDiscipline] = useState('Todas'); // Filtro de disciplina (não usado diretamente na lista, mas pode ser reintroduzido)
  const [disciplines, setDisciplines] = useState([]); // Lista de disciplinas disponíveis (inclui de flashcards e questões)
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false); // Estado para modal de confirmação de exclusão
  const [flashcardToDelete, setFlashcardToDelete] = useState(null); // Flashcard a ser excluído
  const [darkMode, setDarkMode] = useState(false); // Estado para o modo escuro
  const [message, setMessage] = useState(''); // Mensagens de sucesso para o usuário
  const [error, setError] = useState(null); // Mensagens de erro para o usuário
  const [showMenu, setShowMenu] = useState(false); // Estado para exibir/ocultar o menu lateral
  const [quizQuestions, setQuizQuestions] = useState([]); // Questões para o quiz de residência
  const [quizName, setQuizName] = useState(''); // Nome do quiz de residência

  // Define se o usuário atual tem permissão para adicionar questões de residência (admin)
  const RESIDENCY_ADMIN_EMAIL = 'marcomca4@gmail.com'; // E-mail do administrador
  const canAddResidencyQuestion = user && user.email === RESIDENCY_ADMIN_EMAIL;

  /**
   * Hook useEffect para inicializar o Firebase e configurar o listener de autenticação.
   * Executado apenas uma vez ao montar o componente.
   */
  useEffect(() => {
    const initializeFirebaseAndAuth = async () => {
      try {
        const app = initializeApp(currentFirebaseConfig);
        const firestoreDb = getFirestore(app);
        const firebaseAuth = getAuth(app);

        setDb(firestoreDb);
        setAuth(firebaseAuth);

        // Listener para mudanças no estado de autenticação do Firebase
        const unsubscribe = onAuthStateChanged(firebaseAuth, async (currentUser) => {
          if (currentUser) {
            setUser(currentUser);
            setUserId(currentUser.uid);
            console.log('App - Usuário autenticado (onAuthStateChanged):', currentUser.uid);
          } else {
            setUser(null);
            setUserId(null);
            console.log('App - Usuário desautenticado (onAuthStateChanged).');
          }
          setLoadingAuth(false); // Finaliza o estado de carregamento da autenticação
          setAuthChecked(true); // Marca que a verificação inicial foi feita
        });

        // Tenta autenticar com token personalizado do Canvas, se disponível
        if (currentInitialAuthToken) {
          await signInWithCustomToken(firebaseAuth, currentInitialAuthToken);
          console.log('App - Autenticado com token personalizado do Canvas.');
        }

        return () => unsubscribe(); // Cleanup: desinscreve o listener ao desmontar
      } catch (err) {
        console.error('App - Erro ao inicializar Firebase ou autenticar:', err);
        setError('Erro ao carregar o aplicativo: ' + err.message);
        setLoadingAuth(false);
        setAuthChecked(true);
      }
    };

    initializeFirebaseAndAuth();
  }, []); // Array de dependências vazio para executar apenas uma vez

  /**
   * Função para lidar com o login via Google.
   * Utiliza Firebase GoogleAuthProvider para autenticação pop-up.
   */
  const handleGoogleSignIn = async () => {
    if (!auth) {
      setError('Firebase Auth não está inicializado.');
      return;
    }
    setLoadingAuth(true);
    setError(null); // Limpa erros anteriores
    try {
      const provider = new GoogleAuthProvider();
      await signInWithPopup(auth, provider);
      console.log('App - Login com Google bem-sucedido.');
    } catch (err) {
      console.error('App - Erro ao fazer login com Google:', err);
      if (err.code === 'auth/popup-closed-by-user') {
        setError('Login com Google cancelado pelo usuário.');
      } else {
        setError('Erro ao fazer login com Google: ' + err.message);
      }
    } finally {
      setLoadingAuth(false);
    }
  };

  /**
   * Função para lidar com o logout do usuário.
   * Utiliza Firebase signOut.
   */
  const handleSignOut = async () => {
    if (!auth) {
      setError('Firebase Auth não está inicializado.');
      return;
    }
    setLoadingAuth(true);
    setError(null); // Limpa erros anteriores
    try {
      await signOut(auth);
      console.log('App - Usuário deslogado.');
    } catch (err) {
      console.error('App - Erro ao fazer logout:', err);
      setError('Erro ao fazer logout: ' + err.message);
    } finally {
      setLoadingAuth(false);
    }
  };

  /**
   * Hook useEffect para carregar flashcards e disciplinas do Firestore.
   * Inclui flashcards privados do usuário e flashcards de residência públicos.
   * Reage a mudanças em `db`, `userId` e `currentAppId`.
   */
  useEffect(() => {
    if (!db || !userId) {
      console.log('App - Firestore ou userId não disponíveis para buscar flashcards ou disciplinas. Aguardando autenticação.');
      return;
    }

    // Referências às coleções no Firestore
    const userFlashcardsCollectionRef = collection(db, `artifacts/${currentAppId}/users/${userId}/flashcards`);
    const publicResidencyFlashcardsCollectionRef = collection(db, `artifacts/${currentAppId}/public/data/flashcards`);
    const disciplinesCollectionRef = collection(db, `artifacts/${currentAppId}/users/${userId}/disciplines`);

    let tempUserCards = [];
    let tempPublicResidencyCards = [];
    let currentDisciplinesFromCollection = new Set();

    /**
     * Atualiza o estado combinado de disciplinas após cada snapshot.
     * Infere disciplinas dos flashcards do usuário e questões de residência,
     * e mescla com as disciplinas da coleção explícita.
     */
    const updateDisciplines = () => {
      const allCards = [...tempUserCards, ...tempPublicResidencyCards];
      const inferredDisciplines = new Set();
      allCards.forEach(card => {
        if (card.discipline) {
          inferredDisciplines.add(card.discipline);
        } else {
          inferredDisciplines.add('Sem Disciplina'); // Normaliza flashcards sem disciplina
        }
      });

      // Mescla com as disciplinas da coleção explícita e ordena
      const mergedDisciplines = new Set([...currentDisciplinesFromCollection, ...Array.from(inferredDisciplines)]);
      setDisciplines(Array.from(mergedDisciplines).sort());
    };

    // Listener em tempo real para flashcards privados do usuário
    const unsubscribeUserFlashcards = onSnapshot(userFlashcardsCollectionRef, (snapshot) => {
      tempUserCards = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setUserFlashcards(tempUserCards); // Atualiza o estado de flashcards do usuário
      console.log('App - Flashcards do usuário atualizados:', tempUserCards.length);
      updateDisciplines(); // Atualiza disciplinas com base em todos os cards
    }, (err) => {
      console.error("App - Erro ao buscar flashcards do usuário:", err);
      setError("Erro ao carregar flashcards: " + err.message);
    });

    // Listener em tempo real para flashcards de residência públicos
    const unsubscribePublicResidencyFlashcards = onSnapshot(query(publicResidencyFlashcardsCollectionRef, where('type', '==', 'residency')), (snapshot) => {
      tempPublicResidencyCards = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setResidencyQuestions(tempPublicResidencyCards); // Atualiza o estado de questões de residência
      console.log('App - Questões de residência públicos atualizados (PÚBLICO):', tempPublicResidencyCards.length, tempPublicResidencyCards.map(c => ({id: c.id, area: c.area, specialty: c.specialty, question: c.question.substring(0, 30) + '...'})));
      updateDisciplines(); // Atualiza disciplinas com base em todos os cards
    }, (err) => {
      console.error("App - Erro ao buscar questões de residência públicos:", err);
      setError("Erro ao carregar questões de residência: " + err.message);
    });

    // Listener em tempo real para disciplinas (explicitamente gerenciadas pelo usuário)
    const unsubscribeDisciplines = onSnapshot(disciplinesCollectionRef, (snapshot) => {
      currentDisciplinesFromCollection = new Set(snapshot.docs.map(doc => doc.data().name));
      console.log('App - Disciplinas atualizadas (da coleção):', Array.from(currentDisciplinesFromCollection));
      updateDisciplines(); // Atualiza disciplinas com base em todos os cards
    }, (err) => {
      console.error("App - Erro ao buscar disciplinas:", err);
      setError("Erro ao carregar disciplinas: " + err.message);
    });

    // Função de limpeza para desinscrever todos os listeners ao desmontar o componente
    return () => {
      unsubscribeUserFlashcards();
      unsubscribePublicResidencyFlashcards();
      unsubscribeDisciplines();
    };
  }, [db, userId, currentAppId]); // Dependências do useEffect

  /**
   * Adiciona um novo flashcard ao Firestore.
   * Se o flashcard tiver uma nova disciplina, ela também é adicionada.
   * @param {object} newFlashcard - Os dados do novo flashcard.
   */
  const addFlashcard = async (newFlashcard) => {
    if (!db || !userId) {
      setMessage('Erro: Usuário não autenticado ou Firestore não disponível.');
      return;
    }
    try {
      const flashcardsCollectionRef = collection(db, `artifacts/${currentAppId}/users/${userId}/flashcards`);
      await addDoc(flashcardsCollectionRef, {
        ...newFlashcard,
        createdAt: serverTimestamp(), // Adiciona timestamp de criação
        lastReviewedAt: null,
        nextReviewAt: null,
        reviewCount: 0,
        easeFactor: 2.5,
        interval: 0,
        reviewStats: { easy: 0, difficult: 0, forgotten: 0 },
        type: newFlashcard.type || 'simple', // Garante que o tipo seja 'simple' por padrão
      });
      // Adiciona a disciplina se for nova
      if (newFlashcard.discipline && !disciplines.includes(newFlashcard.discipline)) {
        const disciplinesCollectionRef = collection(db, `artifacts/${currentAppId}/users/${userId}/disciplines`);
        await addDoc(disciplinesCollectionRef, { name: newFlashcard.discipline });
      }
      setMessage('Flashcard adicionado com sucesso!');
      setCurrentView('list'); // Retorna para a lista após adicionar
    } catch (e) {
      console.error("App - Erro ao adicionar flashcard: ", e);
      setError("Erro ao adicionar flashcard: " + e.message);
    }
  };

  /**
   * Atualiza um flashcard existente no Firestore.
   * Lida com flashcards simples (privados) e de residência (públicos).
   * @param {string} id - ID do flashcard a ser atualizado.
   * @param {object} updatedData - Os dados atualizados do flashcard.
   */
  const updateFlashcard = async (id, updatedData) => {
    if (!db || !userId) {
      setMessage('Erro: Usuário não autenticado ou Firestore não disponível.');
      return;
    }
    try {
      // Determina se o flashcard é de residência (público) ou simples (privado)
      // Agora, a lógica de encontrar o flashcard deve considerar ambos os estados
      const isResidencyCard = residencyQuestions.find(card => card.id === id); // Verifica se é uma questão de residência
      let docRef;
      if (isResidencyCard) {
        docRef = doc(db, `artifacts/${currentAppId}/public/data/flashcards`, id);
      } else {
        docRef = doc(db, `artifacts/${currentAppId}/users/${userId}/flashcards`, id);
      }

      await updateDoc(docRef, updatedData);
      // Adiciona a disciplina se for nova
      if (updatedData.discipline && !disciplines.includes(updatedData.discipline)) {
        const disciplinesCollectionRef = collection(db, `artifacts/${currentAppId}/users/${userId}/disciplines`);
        await addDoc(disciplinesCollectionRef, { name: updatedData.discipline });
      }
      setMessage('Flashcard atualizado com sucesso!');
      // Não altera a view aqui para permitir que a revisão ou edição continue
    } catch (e) {
      console.error("App - Erro ao atualizar flashcard: ", e);
      setError("Erro ao atualizar flashcard: " + e.message);
    }
  };

  /**
   * Exclui um flashcard do Firestore.
   * Lida com flashcards simples (privados) e de residência (públicos).
   * @param {string} id - ID do flashcard a ser excluído.
   */
  const deleteFlashcard = async (id) => {
    if (!db || !userId) {
      setMessage('Erro: Usuário não autenticado ou Firestore não disponível.');
      return;
    }
    try {
      // Determina se o flashcard é de residência (público) ou simples (privado)
      const isResidencyCard = residencyQuestions.find(card => card.id === id); // Verifica se é uma questão de residência
      let docRef;
      if (isResidencyCard) {
        docRef = doc(db, `artifacts/${currentAppId}/public/data/flashcards`, id);
      } else {
        docRef = doc(db, `artifacts/${currentAppId}/users/${userId}/flashcards`, id);
      }

      await deleteDoc(docRef);
      setMessage('Flashcard excluído com sucesso!');
      setShowDeleteConfirm(false); // Fecha o modal de confirmação
      setFlashcardToDelete(null); // Limpa o flashcard a ser excluído
    } catch (e) {
      console.error("App - Erro ao excluir flashcard: ", e);
      setError("Erro ao excluir flashcard: " + e.message);
    }
  };

  /**
   * Função para navegar entre as diferentes views da aplicação.
   * @param {string} view - O nome da view para a qual navegar.
   * @param {object} [flashcard=null] - Flashcard opcional para edição.
   * @param {Array} [questions=[]] - Questões opcionais para o quiz.
   * @param {string} [quizNameParam=''] - Nome opcional para o quiz.
   */
  const navigateTo = (view, flashcard = null, questions = [], quizNameParam = '') => {
    setCurrentView(view);
    setEditingFlashcard(flashcard);
    setQuizQuestions(questions);
    setQuizName(quizNameParam);
    setMessage(''); // Limpa mensagens anteriores
    setError(null); // Limpa erros anteriores
    setShowMenu(false); // Fecha o menu ao navegar
  };

  // Exibe um spinner de carregamento enquanto a autenticação está em اینڈamento
  if (loadingAuth || !authChecked) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900">
        <p className="text-xl text-gray-700 dark:text-gray-300">Carregando autenticação...</p>
      </div>
    );
  }

  return (
    // Provedor de Contexto de Autenticação para disponibilizar dados de usuário e funções para componentes filhos
    <AuthContext.Provider value={{ user, userId, auth, db, loadingAuth, handleGoogleSignIn, handleSignOut, currentAppId }}>
      {/* Estilos CSS globais para garantir rolagem e tela cheia */}
      <style>
        {`
        html,
        body,
        #root {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-y: auto; /* Permite a rolagem vertical */
        }

        /* Contêiner principal da aplicação React, ocupa toda a viewport */
        .app-container {
            height: 100vh;
            width: 100vw;
            overflow-y: auto; /* Ativa a rolagem vertical se o conteúdo for maior que a tela */
            display: flex;
            flex-direction: column;
            align-items: center; /* Centraliza o conteúdo horizontalmente */
            padding: 1rem; /* Adiciona padding para telas menores */
            box-sizing: border-box; /* Inclui padding na largura/altura total */
        }

        /* Contêiner centralizado para o conteúdo interno da aplicação */
        .content-wrapper {
            max-width: 1280px;
            width: 100%; /* Garante que o wrapper ocupe a largura total disponível até o max-width */
            margin: 0 auto;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1); /* Sombra mais suave */
        }

        /* Estilos para o logo (mantidos do seu CSS original) */
        .logo {
            height: 6em;
            padding: 1.5em;
            will-change: filter;
            transition: filter 300ms;
        }
        .logo:hover {
            filter: drop-shadow(0 0 2em #646cffaa);
        }
        .logo.react:hover {
            filter: drop-shadow(0 0 2em #61dafbaa);
        }

        /* Animação do logo (mantida do seu CSS original) */
        @keyframes logo-spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        @media (prefers-reduced-motion: no-preference) {
            a:nth-of-type(2) .logo {
                animation: logo-spin infinite 20s linear;
            }
        }

        /* Outras classes (mantidas do seu CSS original) */
        .card {
            padding: 2em;
        }

        .read-the-docs {
            color: #888;
        }

        /* Estilos para o placeholder de inputs e textareas */
        input::placeholder, textarea::placeholder {
            color: var(--placeholder-color, #9ca3af); /* Cor padrão para light mode */
            opacity: 1; /* Garante que a cor seja visível */
        }

        /* Estilos para o placeholder em dark mode */
        .dark input::placeholder, .dark textarea::placeholder {
            color: var(--dark-placeholder-color, #6b7280); /* Cor para dark mode */
        }
        `}
      </style>
      {/* Contêiner principal da aplicação com classes de modo escuro e transições */}
      <div className={`app-container ${darkMode ? 'bg-gray-900 text-gray-100' : 'bg-gradient-to-br from-blue-50 to-indigo-100 text-gray-800'} font-sans antialiased transition-colors duration-300`}>
        {/* Wrapper do conteúdo principal com estilos de sombra e borda */}
        <div className={`content-wrapper p-8 rounded-xl shadow-2xl border ${darkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
          {/* Cabeçalho da aplicação */}
          <header className="flex justify-between items-center mb-6 pb-4 border-b-2 border-indigo-200 dark:border-indigo-700">
            <div className="flex items-center">
              {/* Logo do aplicativo */}
              <img src="logo_principal.jpg" alt="FênixQuiz Logo" className="h-52 mr-4"/>
              <h1 className={`text-4xl font-extrabold ${darkMode ? 'text-indigo-400' : 'text-indigo-800'}`}>
                FênixQuiz
              </h1>
            </div>
            {/* Controles do cabeçalho: menu, modo escuro e autenticação */}
            <div className="flex items-center space-x-4">
              {/* Botão para abrir o menu lateral */}
              <button
                onClick={() => setShowMenu(true)}
                className={`p-2 rounded-full ${darkMode ? 'bg-gray-700 text-gray-100' : 'bg-gray-200 text-gray-700'} hover:scale-110 transition-transform duration-200 ease-in-out`}
                aria-label="Abrir menu"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
                </svg>
              </button>

              {/* Botão para alternar modo claro/escuro */}
              <button
                onClick={() => setDarkMode(!darkMode)}
                className={`p-2 rounded-full ${darkMode ? 'bg-gray-700 text-yellow-300' : 'bg-gray-200 text-gray-700'} hover:scale-110 transition-transform duration-200 ease-in-out`}
                aria-label="Alternar modo escuro"
              >
                {darkMode ? (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.325 5.325l-.707.707M6.343 6.343l-.707-.707m12.728 0l-.707-.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                  </svg>
                ) : (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                  </svg>
                )}
              </button>
              {/* Exibe informações do usuário ou botão de login */}
              {user ? (
                <div className="flex items-center space-x-2">
                  <span className={`text-sm ${darkMode ? 'text-gray-300' : 'text-gray-600'}`}>
                    Olá, <span className="font-semibold">{user.displayName || user.email || 'Usuário Anônimo'}</span>
                  </span>
                  <button
                    onClick={handleSignOut}
                    className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
                    aria-label="Sair da conta"
                  >
                    Sair
                  </button>
                </div>
              ) : (
                <button
                  onClick={handleGoogleSignIn}
                  className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md flex items-center space-x-2"
                  aria-label="Entrar com Google"
                >
                  {/* Ícone do Google */}
                  <svg className="w-5 h-5" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M44.5 24.008c0-1.656-.145-3.26-.413-4.82h-20.08v9.125h11.44c-.512 2.744-2.106 5.06-4.54 6.628v7.452h9.58c5.61-5.18 8.8-12.872 8.8-21.385z" fill="#4285F4"/>
                    <path d="M24.417 44.008c6.19 0 11.37-2.05 15.16-5.568l-9.58-7.452c-2.65 1.77-6.075 2.808-9.58 2.808-7.38 0-13.63-4.99-15.86-11.72H3.05v7.625c3.94 7.77 11.95 13.06 21.367 13.06z" fill="#34A853"/>
                    <path d="M8.557 26.837c-.504-1.77-.79-3.65-.79-5.597 0-1.947.286-3.827.79-5.597V7.99h-4.91c-1.39 2.76-2.18 5.86-2.18 9.17 0 3.31 1.01 6.41 2.18 9.17l4.91 7.625v-7.625z" fill="#FBBC05"/>
                    <path d="M24.417 7.99c3.27 0 6.22 1.12 8.52 3.3l8.03-8.03c-4.7-4.38-10.95-6.76-16.55-6.76-11.417 0-19.427 5.29-21.367 13.06l4.91 7.625c2.23-6.73 8.48-11.72 15.86-11.72z" fill="#EA4335"/>
                  </svg>
                  <span>Entrar com Google</span>
                </button>
              )}
            </div>
          </header>

          {/* Menu Overlay (lateral) */}
{showMenu && (
  <div className="fixed inset-0 bg-black bg-opacity-50 z-40 flex justify-start">
    <div className="w-64 bg-white text-gray-800 dark:bg-gray-800 dark:text-gray-100 shadow-lg p-6">
      {/* Botão para fechar o menu */}
      <button
        onClick={() => setShowMenu(false)}
        className="absolute top-4 left-4 p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-100 hover:scale-110 transition-transform duration-200 ease-in-out"
        aria-label="Fechar menu"
      >
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
      {/* Navegação do menu */}
      <nav className="mt-8 space-y-4">
        <button
          onClick={() => navigateTo('list')}
          className="block w-full text-left py-2 px-4 rounded-lg text-gray-700 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-200"
        >
          Meus Flashcards
        </button>
        <button
          onClick={() => navigateTo('statistics')}
          className="block w-full text-left py-2 px-4 rounded-lg text-gray-700 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-200"
        >
          Estatísticas
        </button>
        {/* Opção visível apenas para o administrador */}
        {canAddResidencyQuestion && (
          <button
            onClick={() => navigateTo('add-residency-question')}
            className="block w-full text-left py-2 px-4 rounded-lg text-gray-700 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-200"
          >
            Cadastro de Questões de Residência
          </button>
        )}
        <button
          onClick={() => navigateTo('residency-quiz-setup')}
          className="block w-full text-left py-2 px-4 rounded-lg text-gray-700 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-200"
          aria-label="Resolver questões de residência"
        >
          Resolver Questões de Residência
        </button>
      </nav>
    </div>
  </div>
)}

          {/* Área de exibição de mensagens de erro */}
          {error && (
            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
              <span className="block sm:inline">{error}</span>
            </div>
          )}
          {/* Área de exibição de mensagens de sucesso */}
          {message && (
            <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative mb-4" role="alert">
              <span className="block sm:inline">{message}</span>
            </div>
          )}

          {/* Exibe o ID do usuário se estiver logado */}
          {userId && (
            <div className="text-sm text-gray-500 dark:text-gray-400 mb-6 text-center">
              Seu ID de Usuário (UID): <span className="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded text-xs text-gray-800 dark:text-gray-200">{userId}</span>
            </div>
          )}

          {/* Conteúdo principal da aplicação, renderizado condicionalmente */}
          <main>
            {currentView === 'list' && userId && (
              <FlashcardList
                flashcards={userFlashcards} {/* Agora passa apenas os flashcards do usuário */}
                disciplines={disciplines}
                searchTerm={searchTerm}
                setSearchTerm={setSearchTerm}
                filterDiscipline={filterDiscipline}
                setFilterDiscipline={setFilterDiscipline}
                onEdit={navigateTo}
                onDelete={(flashcard) => { setFlashcardToDelete(flashcard); setShowDeleteConfirm(true); }}
                onAdd={() => navigateTo('add')}
                onReview={() => navigateTo('review')}
                onQuiz={() => navigateTo('residency-quiz-setup')}
                onImportExport={() => navigateTo('import-export')}
                onShare={() => navigateTo('share')}
                darkMode={darkMode}
              />
            )}
            {currentView === 'add' && userId && (
              <FlashcardForm
                onSave={addFlashcard}
                onCancel={() => navigateTo('list')}
                disciplines={disciplines}
                darkMode={darkMode}
              />
            )}
            {currentView === 'edit' && userId && editingFlashcard && (
              <FlashcardForm
                flashcard={editingFlashcard}
                onSave={updateFlashcard}
                onCancel={() => navigateTo('list')}
                disciplines={disciplines}
                darkMode={darkMode}
              />
            )}
            {currentView === 'add-residency-question' && userId && (
              <ResidencyQuestionForm
                onCancel={() => navigateTo('list')}
                disciplines={disciplines}
                darkMode={darkMode}
                canAddResidencyQuestion={canAddResidencyQuestion}
                db={db}
                appId={currentAppId}
                userId={userId}
              />
            )}
            {currentView === 'review' && userId && (
              <FlashcardReview
                allFlashcards={userFlashcards} {/* Revisão é para flashcards do usuário */}
                disciplines={disciplines}
                onUpdateReview={updateFlashcard}
                onBack={() => navigateTo('list')}
                darkMode={darkMode}
              />
            )}
            {currentView === 'quiz' && userId && (
              <FlashcardQuiz
                flashcards={residencyQuestions} {/* Quiz usa questões de residência */}
                onBack={() => navigateTo('list')}
                darkMode={darkMode}
              />
            )}
            {currentView === 'residency-quiz-setup' && userId && (
              <ResidencyQuizSetup
                allFlashcards={residencyQuestions} {/* Setup do quiz usa questões de residência */}
                onStartQuiz={(questions, quizName) => navigateTo('residency-quiz', null, questions, quizName)}
                onBack={() => navigateTo('list')}
                darkMode={darkMode}
                db={db}
                appId={currentAppId}
                setError={setError}
              />
            )}
            {currentView === 'residency-quiz' && userId && quizQuestions.length > 0 && (
              <ResidencyQuiz
                quizQuestions={quizQuestions}
                quizName={quizName}
                onBack={() => navigateTo('list')}
                darkMode={darkMode}
              />
            )}
            {currentView === 'import-export' && userId && (
              <ImportExport
                flashcards={userFlashcards} {/* Import/Export opera sobre flashcards do usuário */}
                onImport={addFlashcard}
                onBack={() => navigateTo('list')}
                darkMode={darkMode}
                disciplines={disciplines} // Pass disciplines to ImportExport
              />
            )}
            {currentView === 'share' && userId && (
              <ShareFlashcards
                userId={userId}
                db={db}
                appId={currentAppId}
                onBack={() => navigateTo('list')}
                setMessage={setMessage}
                setError={setError}
                darkMode={darkMode}
              />
            )}
            {currentView === 'statistics' && userId && (
              <Statistics
                flashcards={userFlashcards} {/* Estatísticas são para flashcards do usuário */}
                disciplines={disciplines}
                onBack={() => navigateTo('list')}
                darkMode={darkMode}
              />
            )}

            {/* Mensagem e botão de login para usuários não autenticados */}
            {!userId && !loadingAuth && authChecked && (
              <section className="text-center py-8 w-full flex flex-col items-center justify-center">
                <p className={`text-lg mb-4 ${darkMode ? 'text-gray-300' : 'text-gray-700'}`}>
                  Para acessar suas funcionalidades, faça login com sua conta Google.
                </p>
                <button
                  onClick={handleGoogleSignIn}
                  className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-lg flex items-center justify-center space-x-2 mx-auto"
                  aria-label="Entrar com Google"
                >
                  {/* Ícone do Google */}
                  <svg className="w-5 h-5" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M44.5 24.008c0-1.656-.145-3.26-.413-4.82h-20.08v9.125h11.44c-.512 2.744-2.106 5.06-4.54 6.628v7.452h9.58c5.61-5.18 8.8-12.872 8.8-21.385z" fill="#4285F4"/>
                    <path d="M24.417 44.008c6.19 0 11.37-2.05 15.16-5.568l-9.58-7.452c-2.65 1.77-6.075 2.808-9.58 2.808-7.38 0-13.63-4.99-15.86-11.72H3.05v7.625c3.94 7.77 11.95 13.06 21.367 13.06z" fill="#34A853"/>
                    <path d="M8.557 26.837c-.504-1.77-.79-3.65-.79-5.597 0-1.947.286-3.827.79-5.597V7.99h-4.91c-1.39 2.76-2.18 5.86-2.18 9.17 0 3.31 1.01 6.41 2.18 9.17l4.91 7.625v-7.625z" fill="#FBBC05"/>
                    <path d="M24.417 7.99c3.27 0 6.22 1.12 8.52 3.3l8.03-8.03c-4.7-4.38-10.95-6.76-16.55-6.76-11.417 0-19.427 5.29-21.367 13.06l4.91 7.625c2.23-6.73 8.48-11.72 15.86-11.72z" fill="#EA4335"/>
                  </svg>
                  <span>Entrar com Google</span>
                </button>
              </section>
            )}
          </main>

          {/* Modal de confirmação de exclusão */}
          {showDeleteConfirm && (
            <DeleteConfirmModal
              flashcard={flashcardToDelete}
              onConfirm={() => deleteFlashcard(flashcardToDelete.id)}
              onCancel={() => setShowDeleteConfirm(false)}
              darkMode={darkMode}
            />
          )}
        </div>
      </div>
    </AuthContext.Provider>
  );
}

// --- Componentes Auxiliares ---
// Em um projeto real, cada um desses componentes estaria em seu próprio arquivo.

/**
 * Componente para exibir o título da disciplina selecionada e o termo de busca.
 * @param {object} props - As props do componente.
 * @param {string} props.disciplineName - O nome da disciplina.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 * @param {function} props.onBackToAll - Função para voltar à visualização de todas as disciplinas.
 * @param {string} props.searchTerm - O termo de busca atual.
 */
const DisciplineTitle = React.memo(({ disciplineName, darkMode, onBackToAll, searchTerm }) => {
  console.log('DisciplineTitle received disciplineName:', disciplineName); // Debug log
  const displayMessage = `Flashcards em "${disciplineName}"`;
  const searchInfo = searchTerm.trim() !== '' ? ` (buscando por "${searchTerm}")` : '';

  return (
    <h3 className={`text-2xl font-bold mb-4 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>
      {displayMessage}{searchInfo}
      <button
        onClick={onBackToAll}
        className="ml-4 text-sm bg-gray-300 hover:bg-gray-400 text-gray-800 py-1 px-3 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 shadow-sm"
        aria-label="Voltar para todas as disciplinas"
      >
        Voltar para Disciplinas
      </button>
    </h3>
  );
},
// Função de comparação para memoização, evita re-renderizações desnecessárias
(prevProps, nextProps) =>
  prevProps.disciplineName === nextProps.disciplineName &&
  prevProps.searchTerm === nextProps.searchTerm &&
  prevProps.darkMode === nextProps.darkMode &&
  prevProps.onBackToAll === nextProps.onBackToAll
);


/**
 * Componente para listar os flashcards, com funcionalidades de busca, filtro por disciplina e navegação.
 * @param {object} props - As props do componente.
 * @param {Array<object>} props.flashcards - Lista de todos os flashcards.
 * @param {Array<string>} props.disciplines - Lista de disciplinas disponíveis.
 * @param {string} props.searchTerm - Termo de busca atual.
 * @param {function} props.setSearchTerm - Função para atualizar o termo de busca.
 * @param {string} props.filterDiscipline - Disciplina selecionada para filtro (não usada diretamente na UI, mas pode ser).
 * @param {function} props.setFilterDiscipline - Função para atualizar a disciplina de filtro.
 * @param {function} props.onEdit - Função de callback para editar um flashcard.
 * @param {function} props.onDelete - Função de callback para excluir um flashcard.
 * @param {function} props.onAdd - Função de callback para adicionar um novo flashcard.
 * @param {function} props.onReview - Função de callback para iniciar a revisão.
 * @param {function} props.onQuiz - Função de callback para iniciar o quiz.
 * @param {function} props.onImportExport - Função de callback para importar/exportar.
 * @param {function} props.onShare - Função de callback para compartilhar.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 */
function FlashcardList({ flashcards, disciplines, searchTerm, setSearchTerm, filterDiscipline, setFilterDiscipline, onEdit, onDelete, onAdd, onReview, onQuiz, onImportExport, onShare, darkMode }) {
  const [selectedDisciplineForDisplay, setSelectedDisciplineForDisplay] = useState('Todas');

  // Callback memoizado para voltar à visualização de todas as disciplinas
  const handleBackToAllDisciplines = useCallback(() => {
    setSelectedDisciplineForDisplay('Todas');
    setSearchTerm(''); // Limpa o termo de busca ao voltar
  }, []);

  // Flashcards filtrados e memoizados para otimização de performance
  const filteredFlashcards = useMemo(() => {
    let currentCards = flashcards;

    if (selectedDisciplineForDisplay !== 'Todas') {
      currentCards = currentCards.filter(card => {
        const cardDiscipline = card.discipline || 'Sem Disciplina'; // Normaliza disciplina
        return cardDiscipline === selectedDisciplineForDisplay;
      });
    }

    if (searchTerm.trim() !== '') {
      currentCards = currentCards.filter(card => {
        const questionMatch = card.question.toLowerCase().includes(searchTerm.toLowerCase());
        const answerMatch = card.answer.toLowerCase().includes(searchTerm.toLowerCase());
        const disciplineMatch = (card.discipline || 'Sem Disciplina').toLowerCase().includes(searchTerm.toLowerCase());
        // Remover areaMatch e specialtyMatch pois flashcards simples não têm esses campos
        // const areaMatch = card.area ? card.area.toLowerCase().includes(searchTerm.toLowerCase()) : false;
        // const specialtyMatch = card.specialty ? card.specialty.toLowerCase().includes(searchTerm.toLowerCase()) : false;
        return questionMatch || answerMatch || disciplineMatch; // || areaMatch || specialtyMatch;
      });
    }

    return currentCards;
  }, [flashcards, searchTerm, selectedDisciplineForDisplay]);

  // Contagem de flashcards por disciplina, memoizada
  const disciplineCounts = useMemo(() => {
    const counts = {};
    flashcards.forEach(card => {
      const disc = card.discipline || 'Sem Disciplina';
      counts[disc] = (counts[disc] || 0) + 1;
    });
    return counts;
  }, [flashcards]);

  // Disciplinas com suas respectivas contagens, memoizadas e ordenadas
  const disciplinesWithCounts = useMemo(() => {
    const uniqueDisciplines = [...new Set(flashcards.map(card => card.discipline || 'Sem Disciplina'))];
    return uniqueDisciplines.map(disc => ({
      name: disc,
      count: disciplineCounts[disc] || 0
    })).sort((a, b) => a.name.localeCompare(b.name));
  }, [flashcards, disciplineCounts]);

  return (
    <section className={`w-full rounded-lg p-4 ${darkMode ? 'bg-gray-700' : 'bg-gray-50'}`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>Meus Flashcards</h2>

      {/* Controles de busca e filtro */}
      <div className="flex flex-col sm:flex-row gap-4 mb-6 px-4">
        <input
          type="text"
          placeholder="Buscar flashcards..."
          value={searchTerm}
          onChange={(e) => {
            setSearchTerm(e.target.value);
            setSelectedDisciplineForDisplay('Todas'); // Reseta o filtro de disciplina ao buscar
          }}
          className={`flex-grow p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400' : 'border-gray-300 text-gray-800 placeholder-gray-500'}`}
          aria-label="Campo de busca de flashcards"
        />
        <select
          value={selectedDisciplineForDisplay}
          onChange={(e) => {
            console.log('Selected discipline in dropdown:', e.target.value); // Debug log
            setSelectedDisciplineForDisplay(e.target.value);
            setSearchTerm(''); // Limpa o termo de busca ao filtrar por disciplina
          }}
          className={`p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
          aria-label="Filtrar flashcards por disciplina"
        >
          <option value="Todas">Todas as Disciplinas</option>
          {disciplines.map(disc => (
            <option key={disc} value={disc}>{disc}</option>
          ))}
        </select>
        <button
          onClick={onAdd}
          className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Adicionar novo flashcard"
        >
          Adicionar Novo
        </button>
      </div>

      {/* Título condicional para disciplina ou resultados de busca */}
      {selectedDisciplineForDisplay !== 'Todas' ? (
        <DisciplineTitle
          key={selectedDisciplineForDisplay}
          disciplineName={selectedDisciplineForDisplay}
          searchTerm={searchTerm}
          darkMode={darkMode}
          onBackToAll={handleBackToAllDisciplines}
        />
      ) : (
        searchTerm.trim() !== '' && (
          <h3 className={`text-2xl font-bold mb-4 px-4 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>
            Resultados da busca para "{searchTerm}"
          </h3>
        )
      )}

      {/* Exibição de flashcards ou disciplinas */}
      {searchTerm.trim() !== '' || selectedDisciplineForDisplay !== 'Todas' ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 px-4 pb-4">
          {filteredFlashcards.length === 0 ? (
            <p className={`col-span-full text-center ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              Nenhum flashcard encontrado com os filtros aplicados.
            </p>
          ) : (
            filteredFlashcards.map(card => (
              <div key={card.id} className={`relative p-6 rounded-xl shadow-lg ${darkMode ? 'bg-gray-800 border border-gray-600' : 'bg-white border border-gray-100'} transition-all duration-200 hover:shadow-xl`}>
                <h3 className={`text-xl font-semibold mb-2 ${darkMode ? 'text-indigo-200' : 'text-indigo-700'}`}>{card.question}</h3>
                {/* Exibição de alternativas para questões de residência (REMOVIDO: FlashcardList agora só mostra flashcards simples) */}
                {/* {card.type === 'residency' && (
                  <div className="mb-4">
                    <p className={`text-sm font-medium ${darkMode ? 'text-gray-300' : 'text-gray-700'}`}>Alternativas:</p>
                    <ul className="list-disc list-inside text-left">
                      {card.alternatives.map((alt, index) => (
                        <li key={index} className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} ${card.correctAnswerIndex === index ? 'font-bold text-green-600' : ''}`}>
                          {String.fromCharCode(65 + index)}. {alt.text}
                        </li>
                      ))}
                    </ul>
                  </div>
                )} */}
                {/* Exibição da resposta para flashcards simples */}
                {/* Removido o condicional de tipo, pois agora só há flashcards simples aqui */}
                <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} mb-4`}>{card.answer}</p>
                {/* Comentário para questões de residência (REMOVIDO) */}
                {/* {card.type === 'residency' && card.comment && (
                  <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'} mb-2`}>
                    <span className="font-medium">Comentário:</span> {card.comment}
                  </p>
                )} */}
                {/* Detalhes da disciplina, área e especialidade */}
                <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                  <span className="font-medium">Disciplina:</span> {card.discipline || 'N/A'}
                </p>
                {/* Removido exibição de área e especialidade, pois flashcards simples não as têm */}
                {/* {card.type === 'residency' && (
                  <>
                    <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                      <span className="font-medium">Área:</span> {card.area || 'N/A'}
                    </p>
                    <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                      <span className="font-medium">Especialidade:</span> {card.specialty || 'N/A'}
                    </p>
                  </>
                )} */}
                {/* Datas de criação e última revisão */}
                <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                  <span className="font-medium">Criado em:</span> {formatDate(card.createdAt)}
                </p>
                <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                  <span className="font-medium">Última Revisão:</span> {formatDate(card.lastReviewedAt)}
                </p>
                {/* Botões de ação */}
                <div className="mt-4 flex space-x-3">
                  <button
                    onClick={() => onEdit('edit', card)}
                    className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-300 ease-in-out transform hover:scale-105"
                    aria-label={`Editar flashcard ${card.question}`}
                  >
                    Editar
                  </button>
                  <button
                    onClick={() => onDelete(card)}
                    className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-300 ease-in-out transform hover:scale-105"
                    aria-label={`Excluir flashcard ${card.question}`}
                  >
                    Excluir
                  </button>
                </div>
              </div>
            ))
          )}
        </div>
      ) : (
        // Exibição de disciplinas como cards clicáveis se nenhum filtro ou busca estiver ativo
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 px-4 pb-4">
          {disciplinesWithCounts.length === 0 ? (
            <p className={`col-span-full text-center ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              Nenhuma disciplina cadastrada. Adicione um flashcard para criar uma!
            </p>
          ) : (
            disciplinesWithCounts.map(disc => (
              <div
                key={disc.name}
                onClick={() => setSelectedDisciplineForDisplay(disc.name)}
                className={`relative p-6 rounded-xl shadow-lg cursor-pointer ${darkMode ? 'bg-gray-800 border border-gray-600' : 'bg-white border border-gray-100'} transition-all duration-200 hover:shadow-xl hover:scale-105`}
                role="button"
                tabIndex="0"
                aria-label={`Ver flashcards da disciplina ${disc.name}`}
              >
                <h3 className={`text-xl font-semibold mb-1 ${darkMode ? 'text-indigo-200' : 'text-indigo-700'}`}>
                  {disc.name}
                </h3>
                <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                  {disc.count} flashcard{disc.count !== 1 ? 's' : ''}
                </p>
              </div>
            ))
          )}
        </div>
      )}

      {/* Botões de navegação para outras funcionalidades */}
      <div className="mt-8 flex flex-wrap justify-center gap-4 px-4 pb-4">
        <button
          onClick={onReview}
          className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Revisar flashcards"
        >
          Revisar Flashcards
        </button>
        <button
          onClick={onQuiz}
          className="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Fazer quiz"
        >
          Fazer Quiz
        </button>
        <button
          onClick={onImportExport}
          className="bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Importar ou exportar flashcards"
        >
          Importar/Exportar
        </button>
        <button
          onClick={onShare}
          className="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Compartilhar flashcards"
        >
          Compartilhar
        </button>
      </div>
    </section>
  );
}

/**
 * Componente de formulário para adicionar ou editar flashcards simples.
 * @param {object} props - As props do componente.
 * @param {object} [props.flashcard] - O flashcard a ser editado (opcional).
 * @param {function} props.onSave - Função de callback para salvar o flashcard.
 * @param {function} props.onCancel - Função de callback para cancelar a operação.
 * @param {Array<string>} props.disciplines - Lista de disciplinas disponíveis.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 */
function FlashcardForm({ flashcard, onSave, onCancel, disciplines, darkMode }) {
  const [question, setQuestion] = useState(flashcard ? flashcard.question : '');
  const [answer, setAnswer] = useState(flashcard ? flashcard.answer : '');
  const [discipline, setDiscipline] = useState('');
  const [newDiscipline, setNewDiscipline] = useState('');
  const [showNewDisciplineInput, setShowNewDisciplineInput] = useState(false);

  // Efeito para inicializar o estado da disciplina ao carregar o formulário
  useEffect(() => {
    if (flashcard) {
      // Se o flashcard tem uma disciplina que não está na lista, permite criar uma nova
      if (flashcard.discipline && !disciplines.includes(flashcard.discipline)) {
        setShowNewDisciplineInput(true);
        setNewDiscipline(flashcard.discipline);
        setDiscipline('new-discipline');
      } else {
        setShowNewDisciplineInput(false);
        setNewDiscipline('');
        setDiscipline(flashcard.discipline || 'Sem Disciplina'); // Define a disciplina existente ou 'Sem Disciplina'
      }
    } else {
      // Para um novo flashcard, tenta preencher com a primeira disciplina ou 'Sem Disciplina'
      if (disciplines.length > 0 && !disciplines.includes('Sem Disciplina')) {
        setShowNewDisciplineInput(false);
        setNewDiscipline('');
        setDiscipline(disciplines[0]);
      } else if (disciplines.includes('Sem Disciplina')) {
        setShowNewDisciplineInput(false);
        setNewDiscipline('');
        setDiscipline('Sem Disciplina');
      } else {
        setShowNewDisciplineInput(true); // Se não há disciplinas, sugere criar uma nova
        setNewDiscipline('');
        setDiscipline('new-discipline');
      }
    }
  }, [flashcard, disciplines]);

  /**
   * Lida com o envio do formulário, chamando a função onSave.
   * @param {Event} e - O evento de submit.
   */
  const handleSubmit = (e) => {
    e.preventDefault();
    const finalDiscipline = showNewDisciplineInput && newDiscipline.trim() !== '' ? newDiscipline.trim() : discipline;

    const dataToSave = {
      question,
      answer,
      discipline: finalDiscipline === 'Sem Disciplina' ? null : finalDiscipline,
      type: 'simple' // Garante que o tipo é simples
    };

    if (flashcard) {
      onSave(flashcard.id, dataToSave);
    } else {
      onSave(dataToSave);
    }
  };

  return (
    <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'}`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>
        {flashcard ? 'Editar Flashcard Simples' : 'Adicionar Novo Flashcard Simples'}
      </h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Campo de Pergunta */}
        <div>
          <label htmlFor="question" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Pergunta</label>
          <textarea
            id="question"
            value={question}
            onChange={(e) => setQuestion(e.target.value)}
            required
            rows="3"
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400' : 'border-gray-300 text-gray-800 placeholder-gray-500'}`}
            placeholder="Digite aqui a pergunta do flashcard..."
            aria-label="Campo para digitar a pergunta do flashcard"
          ></textarea>
        </div>
        {/* Campo de Resposta */}
        <div>
          <label htmlFor="answer" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Resposta</label>
          <textarea
            id="answer"
            value={answer}
            onChange={(e) => setAnswer(e.target.value)}
            required
            rows="3"
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400' : 'border-gray-300 text-gray-800 placeholder-gray-500'}`}
            placeholder="Digite aqui a resposta do flashcard..."
            aria-label="Campo para digitar a resposta do flashcard"
          ></textarea>
        </div>
        {/* Seleção de Disciplina */}
        <div>
          <label htmlFor="discipline" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Disciplina (geral)</label>
          <select
            id="discipline"
            value={discipline}
            onChange={(e) => {
              setDiscipline(e.target.value);
              setShowNewDisciplineInput(e.target.value === 'new-discipline');
              if (e.target.value !== 'new-discipline') {
                setNewDiscipline('');
              }
            }}
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
            aria-label="Selecionar ou criar disciplina"
          >
            {disciplines.map(disc => (
              <option key={disc} value={disc}>{disc}</option>
            ))}
            <option value="new-discipline">Criar Nova Disciplina</option>
          </select>
          {/* Campo para nova disciplina, visível condicionalmente */}
          {showNewDisciplineInput && (
            <input
              type="text"
              placeholder="Nome da nova disciplina"
              value={newDiscipline}
              onChange={(e) => setNewDiscipline(e.target.value)}
              className={`mt-2 w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400' : 'border-gray-300 text-gray-800 placeholder-gray-500'}`}
              required={showNewDisciplineInput}
              aria-label="Campo para digitar o nome da nova disciplina"
            />
          )}
        </div>
        {/* Botões de Ação */}
        <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
          <button
            type="submit"
            className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md w-full sm:w-auto"
            aria-label="Salvar flashcard"
          >
            Salvar Flashcard
          </button>
          <button
            type="button"
            onClick={onCancel}
            className="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md w-full sm:w-auto"
            aria-label="Cancelar operação"
          >
            Cancelar
          </button>
        </div>
      </form>

      {/* Seção de Pré-visualização do Flashcard Simples */}
      <div className={`mt-8 p-6 rounded-xl shadow-lg ${darkMode ? 'bg-gray-800 border border-gray-600' : 'bg-white border border-gray-100'}`}>
        <h3 className={`text-xl font-bold mb-4 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>Pré-visualização do Flashcard Simples</h3>
        <p className={`text-lg font-semibold mb-2 ${darkMode ? 'text-indigo-200' : 'text-indigo-700'}`}>{question || 'Sua pergunta aparecerá aqui...'}</p>
        <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} mb-4`}>{answer || 'Sua resposta aparecerá aqui...'}</p>
        <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
          <span className="font-medium">Disciplina:</span> {discipline || 'N/A'}
        </p>
      </div>
    </section>
  );
}


/**
 * Componente de formulário para adicionar ou editar questões de residência médica.
 * Apenas usuários com permissão de administrador podem adicionar/editar.
 * @param {object} props - As props do componente.
 * @param {object} [props.flashcard] - A questão de residência a ser editada (opcional).
 * @param {function} props.onCancel - Função de callback para cancelar a operação.
 * @param {Array<string>} props.disciplines - Lista de disciplinas disponíveis.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 * @param {boolean} props.canAddResidencyQuestion - Indica se o usuário tem permissão para adicionar/editar.
 * @param {object} props.db - Instância do Firestore.
 * @param {string} props.appId - ID da aplicação.
 * @param {string} props.userId - ID do usuário atual.
 */
function ResidencyQuestionForm({ flashcard, onCancel, disciplines, darkMode, canAddResidencyQuestion, db, appId, userId }) {
  const [question, setQuestion] = useState(flashcard ? flashcard.question : '');
  // Inicializa com 4 alternativas vazias ou as alternativas do flashcard existente
  const [alternatives, setAlternatives] = useState(flashcard && flashcard.type === 'residency' && flashcard.alternatives ? flashcard.alternatives : [{ text: '', isCorrect: false }, { text: '', isCorrect: false }, { text: '', isCorrect: false }, { text: '', isCorrect: false }]);
  const [correctAnswerIndex, setCorrectAnswerIndex] = useState(flashcard && flashcard.type === 'residency' ? flashcard.correctAnswerIndex : -1);
  const [commentText, setCommentText] = useState(flashcard && flashcard.type === 'residency' ? flashcard.comment : '');
  const [showCommentInput, setShowCommentInput] = useState(false); // Controla a visibilidade do campo de comentário
  const [selectedArea, setSelectedArea] = useState(flashcard && flashcard.type === 'residency' ? flashcard.area : '');
  const [selectedSpecialty, setSelectedSpecialty] = useState(flashcard && flashcard.type === 'residency' ? flashcard.specialty : '');
  const [discipline, setDiscipline] = useState('');
  const [newDiscipline, setNewDiscipline] = useState('');
  const [showNewDisciplineInput, setShowNewDisciplineInput] = useState(false);


  // Áreas e especialidades disponíveis, baseadas nas constantes globais
  const availableAreas = Object.keys(AREAS_AND_SPECIALTIES).sort();
  const availableSpecialties = selectedArea ? AREAS_AND_SPECIALTIES[selectedArea].sort() : [];

  // Efeito para inicializar o estado da disciplina ao carregar o formulário
  useEffect(() => {
    if (flashcard) {
      if (flashcard.discipline && !disciplines.includes(flashcard.discipline)) {
        setShowNewDisciplineInput(true);
        setNewDiscipline(flashcard.discipline);
        setDiscipline('new-discipline');
      } else {
        setShowNewDisciplineInput(false);
        setNewDiscipline('');
        setDiscipline(flashcard.discipline || 'Sem Disciplina');
      }
    } else {
      if (disciplines.length > 0 && !disciplines.includes('Sem Disciplina')) {
        setShowNewDisciplineInput(false);
        setNewDiscipline('');
        setDiscipline(disciplines[0]);
      } else if (disciplines.includes('Sem Disciplina')) {
        setShowNewDisciplineInput(false);
        setNewDiscipline('');
        setDiscipline('Sem Disciplina');
      } else {
        setShowNewDisciplineInput(true);
        setNewDiscipline('');
        setDiscipline('new-discipline');
      }
    }
  }, [flashcard, disciplines]);

  /**
   * Lida com a mudança de texto em uma alternativa.
   * @param {number} index - Índice da alternativa.
   * @param {string} value - Novo texto da alternativa.
   */
  const handleAlternativeChange = (index, value) => {
    const newAlternatives = [...alternatives];
    newAlternatives[index].text = value;
    setAlternatives(newAlternatives);
  };

  /**
   * Lida com a seleção da alternativa correta.
   * @param {number} index - Índice da alternativa correta.
   */
  const handleCorrectAnswerChange = (index) => {
    setCorrectAnswerIndex(index);
  };

  /**
   * Adiciona uma nova alternativa vazia.
   */
  const handleAddAlternative = () => {
    setAlternatives([...alternatives, { text: '', isCorrect: false }]);
  };

  /**
   * Remove uma alternativa pelo índice.
   * Ajusta o índice da resposta correta se necessário.
   * @param {number} index - Índice da alternativa a ser removida.
   */
  const handleRemoveAlternative = (index) => {
    const newAlternatives = alternatives.filter((_, i) => i !== index);
    if (correctAnswerIndex === index) {
      setCorrectAnswerIndex(-1); // Reseta a resposta correta se ela foi removida
    } else if (correctAnswerIndex > index) {
      setCorrectAnswerIndex(correctAnswerIndex - 1); // Ajusta o índice se a correta estava após a removida
    }
    setAlternatives(newAlternatives);
  };

  /**
   * Lida com o envio do formulário para salvar ou atualizar a questão de residência.
   * Realiza validações antes de salvar no Firestore.
   * @param {Event} e - O evento de submit.
   */
  const handleSubmit = async (e) => {
    e.preventDefault();
    const finalDiscipline = showNewDisciplineInput && newDiscipline.trim() !== '' ? newDiscipline.trim() : discipline;

    // Validações específicas para questões de residência
    const filledAlternatives = alternatives.filter(alt => alt.text.trim() !== '');
    if (filledAlternatives.length < 2) {
      console.error("ResidencyQuestionForm - Por favor, adicione pelo menos duas alternativas preenchidas.");
      // Poderia exibir uma mensagem de erro para o usuário aqui
      return;
    }
    if (correctAnswerIndex === -1 || correctAnswerIndex >= alternatives.length || alternatives[correctAnswerIndex].text.trim() === '') {
      console.error("ResidencyQuestionForm - Por favor, selecione uma alternativa correta válida.");
      // Poderia exibir uma mensagem de erro para o usuário aqui
      return;
    }
    if (!selectedArea || !selectedSpecialty) {
      console.error("ResidencyQuestionForm - Por favor, selecione a Área e a Especialidade.");
      // Poderia exibir uma mensagem de erro para o usuário aqui
      return;
    }

    // Dados da questão a serem salvos
    const questionData = {
      type: 'residency',
      question,
      alternatives: alternatives.map((alt, index) => ({
        text: alt.text,
        isCorrect: index === correctAnswerIndex // Define isCorrect com base no índice selecionado
      })).filter(alt => alt.text.trim() !== ''), // Filtra alternativas vazias
      correctAnswerIndex: correctAnswerIndex, // Salva o índice da resposta correta
      comment: commentText,
      area: selectedArea,
      specialty: selectedSpecialty,
      discipline: finalDiscipline === 'Sem Disciplina' ? null : finalDiscipline,
      ownerId: userId, // Armazena o ID do usuário que criou a questão
    };

    try {
      const publicFlashcardsRef = collection(db, `artifacts/${appId}/public/data/flashcards`);

      if (flashcard) {
        // Se estiver editando, atualiza o flashcard existente na coleção pública
        const docRef = doc(db, `artifacts/${appId}/public/data/flashcards`, flashcard.id);
        await updateDoc(docRef, questionData);
        console.log("ResidencyQuestionForm - Questão de residência atualizada na coleção pública:", flashcard.id);
      } else {
        // Se estiver adicionando, adiciona à coleção pública
        await addDoc(publicFlashcardsRef, { ...questionData, createdAt: serverTimestamp() }); // Adiciona timestamp de criação
        console.log("ResidencyQuestionForm - Nova questão de residência adicionada à coleção pública.");
      }
      onCancel(); // Retorna para a lista após salvar
    } catch (e) {
      console.error("ResidencyQuestionForm - Erro ao salvar questão de residência na coleção pública: ", e);
      // Implementar feedback visual de erro para o usuário
    }
  };

  // Exibe uma mensagem de permissão se o usuário não for administrador e não estiver editando um flashcard existente
  if (!canAddResidencyQuestion && !flashcard) {
    return (
      <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
        <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>
          Cadastro de Questões de Residência
        </h2>
        <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} text-lg mb-4`}>
          Apenas usuários autorizados podem cadastrar novas questões de residência.
        </p>
        <button
          onClick={onCancel}
          className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Voltar para a lista de flashcards"
        >
          Voltar
        </button>
      </section>
    );
  }

  return (
    <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'}`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>
        {flashcard ? 'Editar Questão de Residência' : 'Adicionar Nova Questão de Residência'}
      </h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        
	  <div>
  <label
    htmlFor="question"
    className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}
  >
    Pergunta
  </label>
  <textarea
    id="question"
    value={question}
    onChange={(e) => setQuestion(e.target.value)}
    required
    rows="3"
    className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${
      darkMode
        ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400'
        : 'bg-gray-100 border-gray-300 text-gray-800 placeholder-gray-500'
    }`}
    placeholder="Digite aqui a questão..."
    readOnly={!canAddResidencyQuestion && !flashcard} // Somente leitura se não for admin ou não estiver editando
    aria-label="Campo para digitar a pergunta da questão de residência"
  ></textarea>
</div>


        {/* Seção de Alternativas */}
        <div className="space-y-3">
          <label className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Alternativas:</label>
          {alternatives.map((alt, index) => (
            <div key={index} className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-2">
              <input
                type="radio"
                name="correctAlternative"
                checked={correctAnswerIndex === index}
                onChange={() => handleCorrectAnswerChange(index)}
                className="form-radio text-green-600"
                disabled={!canAddResidencyQuestion && !flashcard} // Desabilitado se não for admin ou não estiver editando
                aria-label={`Marcar alternativa ${String.fromCharCode(65 + index)} como correta`}
              />
              <span className={`font-semibold ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>{String.fromCharCode(65 + index)}:</span>
              <input
                type="text"
                value={alt.text}
                onChange={(e) => handleAlternativeChange(index, e.target.value)}
                className={`flex-grow p-2 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
                placeholder={`Alternativa ${String.fromCharCode(65 + index)}`}
                readOnly={!canAddResidencyQuestion && !flashcard} // Somente leitura se não for admin ou não estiver editando
                aria-label={`Campo para digitar a alternativa ${String.fromCharCode(65 + index)}`}
              />
              {/* Botão para remover alternativa (visível apenas para admin e se houver mais de 2 alternativas) */}
              {canAddResidencyQuestion && alternatives.length > 2 && (
                <button
                  type="button"
                  onClick={() => handleRemoveAlternative(index)}
                  className="text-red-500 hover:text-red-700 p-1 rounded-full transition-colors duration-200"
                  aria-label="Remover alternativa"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" stroke="currentColor">
                    <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clipRule="evenodd" />
                  </svg>
                </button>
              )}
            </div>
          ))}
          {/* Botão para adicionar nova alternativa (visível apenas para admin) */}
          {canAddResidencyQuestion && (
            <button
              type="button"
              onClick={handleAddAlternative}
              className="mt-2 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-300 ease-in-out transform hover:scale-105 shadow-md flex items-center justify-center space-x-2"
              aria-label="Adicionar nova alternativa"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
              </svg>
              <span>Adicionar Nova Alternativa</span>
            </button>
          )}
        </div>

        {/* Seção de Comentário */}
<div className="mt-6">
  <button
    type="button"
    onClick={() => setShowCommentInput(!showCommentInput)}
    className="flex items-center space-x-2 text-sm font-medium text-white hover:text-indigo-600 transition-colors duration-200"
    aria-label={showCommentInput ? 'Ocultar campo de comentário' : 'Mostrar campo de comentário'}
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-6 w-6"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"
      />
    </svg>
    <span>
      {showCommentInput ? 'Ocultar Comentário' : 'Adicionar/Visualizar Comentário'}
    </span>
  </button>
  {showCommentInput && (
    <textarea
      value={commentText}
      onChange={(e) => setCommentText(e.target.value)}
      rows="4"
      className={`mt-2 w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${
        darkMode
          ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400'
          : 'bg-gray-100 border-gray-300 text-gray-800 placeholder-gray-500'
      }`}
      placeholder="Adicione um comentário explicativo para a questão..."
      readOnly={!canAddResidencyQuestion && !flashcard}
      aria-label="Campo para digitar o comentário da questão"
    ></textarea>
  )}
</div>



        {/* Seleção de Área */}
        <div className="mt-6">
          <label htmlFor="area" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Área</label>
          <select
            id="area"
            value={selectedArea}
            onChange={(e) => { setSelectedArea(e.target.value); setSelectedSpecialty(''); }}
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
            required
            disabled={!canAddResidencyQuestion && !flashcard} // Desabilitado se não for admin ou não estiver editando
            aria-label="Selecionar área da questão"
          >
            <option value="">Selecione uma Área</option>
            {availableAreas.map(area => (
              <option key={area} value={area}>{area}</option>
            ))}
          </select>
        </div>

        {/* Seleção de Especialidade */}
        <div className="mt-4">
          <label htmlFor="specialty" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Especialidade</label>
          <select
            id="specialty"
            value={selectedSpecialty}
            onChange={(e) => setSelectedSpecialty(e.target.value)}
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
            disabled={!selectedArea || (!canAddResidencyQuestion && !flashcard)} // Desabilita se nenhuma área selecionada ou não for admin/editando
            required
            aria-label="Selecionar especialidade da questão"
          >
            <option value="">Selecione uma Especialidade</option>
            {availableSpecialties.map(specialty => (
              <option key={specialty} value={specialty}>{specialty}</option>
            ))}
          </select>
        </div>

        {/* Seleção de Disciplina (geral) */}
        <div>
          <label htmlFor="discipline" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Disciplina (geral)</label>
          <select
            id="discipline"
            value={discipline}
            onChange={(e) => {
              setDiscipline(e.target.value);
              setShowNewDisciplineInput(e.target.value === 'new-discipline');
              if (e.target.value !== 'new-discipline') {
                setNewDiscipline('');
              }
            }}
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
            disabled={!canAddResidencyQuestion && !flashcard} // Desabilitado se não for admin ou não estiver editando
            aria-label="Selecionar ou criar disciplina geral"
          >
            {disciplines.map(disc => (
              <option key={disc} value={disc}>{disc}</option>
            ))}
            {canAddResidencyQuestion && <option value="new-discipline">Criar Nova Disciplina</option>}
          </select>
          {/* Campo para nova disciplina (visível apenas para admin e se selecionado) */}
          {showNewDisciplineInput && canAddResidencyQuestion && (
            <input
              type="text"
              placeholder="Nome da nova disciplina"
              value={newDiscipline}
              onChange={(e) => setNewDiscipline(e.target.value)}
              className={`mt-2 w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400' : 'border-gray-300 text-gray-800 placeholder-gray-500'}`}
              required={showNewDisciplineInput}
              aria-label="Campo para digitar o nome da nova disciplina"
            />
          )}
        </div>

        {/* Botões de Ação */}
        <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
          <button
            type="submit"
            className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md w-full sm:w-auto"
            disabled={!canAddResidencyQuestion && !flashcard} // Desabilitado se não for admin ou não estiver editando
            aria-label="Salvar questão de residência"
          >
            Salvar Questão
          </button>
          <button
            type="button"
            onClick={onCancel}
            className="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md w-full sm:w-auto"
            aria-label="Cancelar operação"
          >
            Cancelar
          </button>
        </div>
      </form>

      {/* Seção de Pré-visualização da Questão de Residência */}
      <div className={`mt-8 p-6 rounded-xl shadow-lg ${darkMode ? 'bg-gray-800 border border-gray-600' : 'bg-white border border-gray-100'}`}>
        <h3 className={`text-xl font-bold mb-4 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>Pré-visualização da Questão de Residência</h3>
        <p className={`text-lg font-semibold mb-2 ${darkMode ? 'text-indigo-200' : 'text-indigo-700'}`}>{question || 'Sua pergunta aparecerá aqui...'}</p>

        <div className="mb-4">
          <p className={`text-sm font-medium ${darkMode ? 'text-gray-300' : 'text-gray-700'}`}>Alternativas:</p>
          <ul className="list-disc list-inside text-left">
            {alternatives.filter(alt => alt.text.trim() !== '').map((alt, index) => (
              <li key={index} className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} ${correctAnswerIndex === index ? 'font-bold text-green-600' : ''}`}>
                {String.fromCharCode(65 + index)}. {alt.text}
              </li>
            ))}
          </ul>
        </div>

        {commentText && (
          <div className="mt-2">
            <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
              <span className="font-medium">Comentário:</span> {commentText}
            </p>
          </div>
        )}
        {selectedArea && (
          <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
            <span className="font-medium">Área:</span> {selectedArea}
          </p>
        )}
        {selectedSpecialty && (
          <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
            <span className="font-medium">Especialidade:</span> {selectedSpecialty}
          </p>
        )}
        <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
          <span className="font-medium">Disciplina:</span> {discipline || 'N/A'}
        </p>
      </div>
    </section>
  );
}


/**
 * Componente de modal para confirmar a exclusão de um flashcard.
 * @param {object} props - As props do componente.
 * @param {object} props.flashcard - O flashcard a ser excluído.
 * @param {function} props.onConfirm - Função de callback para confirmar a exclusão.
 * @param {function} props.onCancel - Função de callback para cancelar a exclusão.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 */
function DeleteConfirmModal({ flashcard, onConfirm, onCancel, darkMode }) {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className={`p-8 rounded-xl shadow-2xl w-full max-w-md text-center ${darkMode ? 'bg-gray-800 text-gray-100' : 'bg-white text-gray-800'}`}>
        <h3 className={`text-2xl font-bold mb-4 ${darkMode ? 'text-red-400' : 'text-red-700'}`}>Confirmar Exclusão</h3>
        <p className="mb-6">Tem certeza que deseja excluir o flashcard: <span className="font-semibold">"{flashcard.question}"</span>?</p>
        <div className="flex justify-center space-x-4">
          <button
            onClick={onConfirm}
            className="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
            aria-label={`Confirmar exclusão do flashcard ${flashcard.question}`}
          >
            Sim, Excluir
          </button>
          <button
            onClick={onCancel}
            className="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
            aria-label="Cancelar exclusão"
          >
            Cancelar
          </button>
        </div>
      </div>
    </div>
  );
}

/**
 * Componente para a revisão de flashcards, com seleção de disciplina e feedback de revisão.
 * @param {object} props - As props do componente.
 * @param {Array<object>} props.allFlashcards - Lista de todos os flashcards disponíveis.
 * @param {function} props.onUpdateReview - Função para atualizar os dados de revisão de um flashcard.
 * @param {function} props.onBack - Função para voltar à tela anterior.
 * @param {Array<string>} props.disciplines - Lista de disciplinas disponíveis.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 */
function FlashcardReview({ allFlashcards, onUpdateReview, onBack, disciplines, darkMode }) {
  const [selectedReviewDiscipline, setSelectedReviewDiscipline] = useState('Todas');
  const [currentCardIndex, setCurrentCardIndex] = useState(0);
  const [showAnswer, setShowAnswer] = useState(false);

  // Filtra os flashcards com base na disciplina selecionada, memoizado para performance
  const filteredReviewCards = useMemo(() => {
    if (selectedReviewDiscipline === 'Todas') {
      return allFlashcards;
    }
    return allFlashcards.filter(card => {
      const cardDiscipline = card.discipline || 'Sem Disciplina';
      return cardDiscipline === selectedReviewDiscipline;
    });
  }, [allFlashcards, selectedReviewDiscipline]);

  // Redefine o índice e o estado da resposta quando a disciplina de revisão muda
  useEffect(() => {
    setCurrentCardIndex(0);
    setShowAnswer(false);
  }, [selectedReviewDiscipline]);

  const currentCard = filteredReviewCards[currentCardIndex];

  /**
   * Lida com a ação de passar para o próximo flashcard, registrando a qualidade da revisão.
   * @param {number} quality - Qualidade da revisão (0: Esqueci, 3: Difícil, 5: Fácil).
   */
  const handleNextCard = async (quality) => {
    if (!currentCard) return;

    // Atualiza as estatísticas de revisão do flashcard
    const updatedReviewStats = { ...currentCard.reviewStats };
    updatedReviewStats.easy = updatedReviewStats.easy || 0;
    updatedReviewStats.difficult = updatedReviewStats.difficult || 0;
    updatedReviewStats.forgotten = updatedReviewStats.forgotten || 0;

    if (quality === 5) {
      updatedReviewStats.easy += 1;
    } else if (quality === 3) {
      updatedReviewStats.difficult += 1;
    } else if (quality === 0) {
      updatedReviewStats.forgotten += 1;
    }

    // Chama a função para atualizar o flashcard no Firestore
    await onUpdateReview(currentCard.id, {
      reviewStats: updatedReviewStats,
      lastReviewedAt: serverTimestamp(), // Atualiza a data da última revisão
    });

    setShowAnswer(false); // Esconde a resposta para o próximo card
    // Avança para o próximo flashcard ou retorna à lista se todos foram revisados
    if (currentCardIndex < filteredReviewCards.length - 1) {
      setCurrentCardIndex(currentCardIndex + 1);
    } else {
      onBack(); // Fim da revisão
    }
  };

  // Exibe mensagem se não houver flashcards para revisar
  if (filteredReviewCards.length === 0) {
    return (
      <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
        <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} text-lg mb-4`}>
          Nenhum flashcard para revisar
          {selectedReviewDiscipline !== 'Todas' ? ` na disciplina "${selectedReviewDiscipline}"` : ''} no momento.
        </p>
        <button
          onClick={onBack}
          className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Voltar para a lista de flashcards"
        >
          Voltar para a Lista
        </button>
      </section>
    );
  }

  return (
    <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>Revisar Flashcards</h2>

      {/* Dropdown para filtrar por disciplina */}
      <div className="mb-4">
        <label htmlFor="reviewDiscipline" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>
          Filtrar por Disciplina:
        </label>
        <select
          id="reviewDiscipline"
          value={selectedReviewDiscipline}
          onChange={(e) => setSelectedReviewDiscipline(e.target.value)}
          className={`p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
          aria-label="Selecionar disciplina para revisão"
        >
          <option value="Todas">Todas as Disciplinas</option>
          {disciplines.map(disc => (
            <option key={disc} value={disc}>{disc}</option>
          ))}
        </select>
      </div>

      {currentCard ? (
        <div className={`p-8 rounded-xl shadow-lg ${darkMode ? 'bg-gray-800 border border-gray-600' : 'bg-white border border-gray-100'} min-h-[200px] flex flex-col justify-between`}>
          <p className={`text-xl font-semibold mb-4 ${darkMode ? 'text-indigo-200' : 'text-indigo-700'}`}>{currentCard.question}</p>
          {/* Exibição de alternativas para questões de residência */}
          {currentCard.type === 'residency' && (
            <div className="mb-4 text-left">
              <p className={`text-sm font-medium ${darkMode ? 'text-gray-300' : 'text-gray-700'}`}>Alternativas:</p>
              <ul className="list-disc list-inside">
                {currentCard.alternatives.map((alt, index) => (
                  <li key={index} className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} ${showAnswer && currentCard.correctAnswerIndex === index ? 'font-bold text-green-600' : ''}`}>
                    {String.fromCharCode(65 + index)}. {alt.text}
                  </li>
                ))}
              </ul>
            </div>
          )}
          {/* Exibição da resposta ou comentário se a resposta for mostrada */}
          {showAnswer && currentCard.type !== 'residency' && (
            <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} text-lg mt-4`}>{currentCard.answer}</p>
          )}
          {showAnswer && currentCard.type === 'residency' && currentCard.comment && (
            <div className="mt-4 text-left">
              <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
                <span className="font-medium">Comentário:</span> {currentCard.comment}
              </p>
            </div>
          )}
          <div className="mt-6">
            {/* Botão para mostrar a resposta */}
            {!showAnswer ? (
              <button
                onClick={() => setShowAnswer(true)}
                className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
                aria-label="Mostrar resposta do flashcard"
              >
                Mostrar Resposta
              </button>
            ) : (
              // Botões de feedback de revisão
              <div className="flex flex-col sm:flex-row justify-center space-y-2 sm:space-y-0 sm:space-x-4">
                <button
                  onClick={() => handleNextCard(0)}
                  className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out w-full sm:w-auto"
                  aria-label="Marcar como esquecido"
                >
                  Esqueci
                </button>
                <button
                  onClick={() => handleNextCard(3)}
                  className="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out w-full sm:w-auto"
                  aria-label="Marcar como difícil"
                >
                  Lembrei (Difícil)
                </button>
                <button
                  onClick={() => handleNextCard(5)}
                  className="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out w-full sm:w-auto"
                  aria-label="Marcar como fácil"
                >
                  Lembrei (Fácil)
                </button>
              </div>
            )}
          </div>
        </div>
      ) : (
        <p className={`${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>Carregando flashcard...</p>
      )}
      <button
        onClick={onBack}
        className="mt-6 bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
        aria-label="Voltar para a lista de flashcards"
      >
        Voltar
      </button>
    </section>
  );
}

/**
 * Componente para configurar um quiz de questões de residência.
 * Permite filtrar por área, especialidade e definir o número de questões.
 * @param {object} props - As props do componente.
 * @param {Array<object>} props.allFlashcards - Todos os flashcards de residência disponíveis.
 * @param {function} props.onStartQuiz - Função de callback para iniciar o quiz.
 * @param {function} props.onBack - Função para voltar à tela anterior.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 * @param {object} props.db - Instância do Firestore.
 * @param {string} props.appId - ID da aplicação.
 * @param {function} props.setError - Função para definir mensagens de erro.
 */
function ResidencyQuizSetup({ allFlashcards, onStartQuiz, onBack, darkMode, db, appId, setError }) {
  const [selectedArea, setSelectedArea] = useState('Todas');
  const [selectedSpecialty, setSelectedSpecialty] = useState('Todas');
  const [numberOfQuestions, setNumberOfQuestions] = useState(10);
  const [availableQuestions, setAvailableQuestions] = useState([]);
  const [quizTitle, setQuizTitle] = useState('');

  // Áreas e especialidades disponíveis, incluindo a opção 'Todas'
  const availableAreas = ['Todas', ...Object.keys(AREAS_AND_SPECIALTIES).sort()];
  const availableSpecialties = selectedArea === 'Todas'
    ? ['Todas', ...new Set(Object.values(AREAS_AND_SPECIALTIES).flat())].sort()
    : ['Todas', ...(AREAS_AND_SPECIALTIES[selectedArea] || [])].sort();

  /**
   * Hook useEffect para buscar e filtrar questões de residência do Firestore.
   * Reage a mudanças em `db`, `appId`, `selectedArea` e `selectedSpecialty`.
   * AGORA RECEBE allFlashcards DIRETAMENTE DO APP, NÃO PRECISA BUSCAR AQUI.
   */
  useEffect(() => {
    // Remove a busca no Firestore aqui, pois `allFlashcards` já vem do App.
    // Apenas filtra as questões que já foram passadas via prop.
    let filtered = allFlashcards;
    if (selectedArea !== 'Todas') {
      filtered = filtered.filter(card => card.area === selectedArea);
    }
    if (selectedSpecialty !== 'Todas') {
      filtered = filtered.filter(card => card.specialty === selectedSpecialty);
    }
    setAvailableQuestions(filtered);
    console.log('ResidencyQuizSetup - Questões de residência FILTRADAS (final):', filtered.length);
  }, [allFlashcards, selectedArea, selectedSpecialty]); // Dependências atualizadas

  /**
   * Lida com o início do quiz, validando as configurações e selecionando as questões.
   */
  const handleStartQuiz = () => {
    console.log('handleStartQuiz - Título do Quiz:', quizTitle);
    console.log('handleStartQuiz - Questões disponíveis ANTES do shuffle/slice:', availableQuestions.length);

    if (quizTitle.trim() === '') {
      setError("Por favor, dê um nome ao seu bloco de questões.");
      return;
    }

    if (availableQuestions.length === 0) {
      setError("Não há questões disponíveis com os filtros selecionados.");
      console.error("handleStartQuiz - Não há questões disponíveis com os filtros selecionados.");
      return;
    }

    // Embaralha e seleciona as questões para o quiz
    const shuffledQuestions = [...availableQuestions].sort(() => 0.5 - Math.random());
    const questionsForQuiz = shuffledQuestions.slice(0, Math.min(numberOfQuestions, shuffledQuestions.length));

    console.log('handleStartQuiz - Questões selecionadas para o quiz:', questionsForQuiz.length);

    if (questionsForQuiz.length === 0) {
      setError("Não foi possível montar um quiz com as questões disponíveis e a quantidade solicitada.");
      console.error("handleStartQuiz - Não foi possível montar um quiz com as questões disponíveis e a quantidade solicitada.");
      return;
    }

    onStartQuiz(questionsForQuiz, quizTitle); // Inicia o quiz com as questões selecionadas e o título
  };

  return (
    <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>Configurar Quiz de Residência</h2>

      <div className="space-y-4 mb-6">
        {/* Campo para o nome do bloco de questões */}

{/* Campo para o nome do bloco de questões */}


{/* Campo para o nome do bloco de questões */}
<div>
  <label
    htmlFor="quizTitle"
    className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}
  >
    Nome do Bloco de Questões:
  </label>
  <input
    type="text"
    id="quizTitle"
    value={quizTitle}
    onChange={(e) => setQuizTitle(e.target.value)}
    className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${
      darkMode
        ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400'
        : 'bg-gray-100 border-gray-300 text-gray-800 placeholder-gray-500'
    }`}
    placeholder="Ex: Quiz de Cardiologia - Prova 2023"
    required
    aria-label="Nome do bloco de questões"
  />
</div>

        {/* Dropdown para selecionar a Área */}
        <div>
          <label htmlFor="areaSelect" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Área:</label>
          <select
            id="areaSelect"
            value={selectedArea}
            onChange={(e) => setSelectedArea(e.target.value)}
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
            aria-label="Selecionar área"
          >
            <option value="">Selecione uma Área</option>
            {availableAreas.map(area => (
              <option key={area} value={area}>{area}</option>
            ))}
          </select>
        </div>

        {/* Dropdown para selecionar a Especialidade */}
        <div>
          <label htmlFor="specialtySelect" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Especialidade:</label>
          <select
            id="specialtySelect"
            value={selectedSpecialty}
            onChange={(e) => setSelectedSpecialty(e.target.value)}
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
            disabled={!selectedArea || selectedArea === 'Todas'} // Desabilita se nenhuma área selecionada
            required
            aria-label="Selecionar especialidade"
          >
            <option value="">Selecione uma Especialidade</option>
            {availableSpecialties.map(specialty => (
              <option key={specialty} value={specialty}>{specialty}</option>
            ))}
          </select>
        </div>

        {/* Campo para definir a quantidade de questões */}
<div>
          <label htmlFor="numQuestions" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Quantidade de Questões:</label>
          <input
            type="number"
            id="numQuestions"
            value={numberOfQuestions}
            onChange={(e) => setNumberOfQuestions(Math.max(1, parseInt(e.target.value) || 1))} // Garante que o número seja pelo menos 1
            min="1"
            max={availableQuestions.length > 0 ? availableQuestions.length : 1} // Máximo é o número de questões disponíveis
            className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'border-gray-300 text-gray-800'}`}
            aria-label="Quantidade de questões para o quiz"
          />
          <p className={`text-sm mt-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
            Questões disponíveis com estes filtros: {availableQuestions.length}
          </p>
        </div>
      </div>


{/* Botões de ação */}
      <div className="flex flex-col sm:flex-row justify-center space-y-2 sm:space-y-0 sm:space-x-4">
        <button
          onClick={handleStartQuiz}
          className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md w-full sm:w-auto"
          aria-label="Iniciar quiz"
        >
          Iniciar Quiz
        </button>
        <button
          onClick={onBack}
          className="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md w-full sm:w-auto"
          aria-label="Voltar para a tela anterior"
        >
          Voltar
        </button>
      </div>
    </section>
  );
}


/**
 * Componente para realizar um quiz de questões de residência.
 * Exibe uma questão por vez, permite selecionar a resposta e verificar.
 * @param {object} props - As props do componente.
 * @param {Array<object>} props.quizQuestions - As questões selecionadas para o quiz.
 * @param {function} props.onBack - Função para voltar à tela anterior.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 * @param {string} props.quizName - O nome do quiz.
 */
function ResidencyQuiz({ quizQuestions, onBack, darkMode, quizName }) {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [selectedAnswerIndex, setSelectedAnswerIndex] = useState(null);
  const [showResult, setShowResult] = useState(false); // Controla a exibição do resultado da resposta
  const [showComment, setShowComment] = useState(false); // Controla a visibilidade do comentário
  const [answeredQuestionsCount, setAnsweredQuestionsCount] = useState(0); // Conta as questões respondidas

  const currentQuestion = quizQuestions[currentQuestionIndex];

  /**
   * Lida com a seleção de uma alternativa.
   * Permite selecionar apenas se o resultado da questão ainda não foi exibido.
   * @param {number} index - Índice da alternativa selecionada.
   */
  const handleAnswerSelection = (index) => {
    if (!showResult) {
      setSelectedAnswerIndex(index);
    }
  };

  /**
   * Lida com o envio da resposta, exibe o resultado e incrementa o contador de questões respondidas.
   */
  const handleSubmitAnswer = () => {
    if (selectedAnswerIndex === null) {
      console.error("ResidencyQuiz - Por favor, selecione uma alternativa antes de enviar.");
      // Poderia exibir uma mensagem de erro para o usuário
      return;
    }
    setShowResult(true);
    setAnsweredQuestionsCount(prev => prev + 1);
  };

  /**
   * Lida com a navegação para a próxima questão ou o fim do quiz.
   */
  const handleNextQuestion = () => {
    setSelectedAnswerIndex(null); // Reseta a seleção
    setShowResult(false); // Esconde o resultado
    setShowComment(false); // Esconde o comentário
    if (currentQuestionIndex < quizQuestions.length - 1) {
      setCurrentQuestionIndex(currentQuestionIndex + 1); // Avança para a próxima questão
    } else {
      console.log("ResidencyQuiz - Fim do quiz!");
      onBack(); // Retorna à tela anterior (lista ou setup do quiz)
    }
  };

  // Exibe mensagem se não houver questões para o quiz
  if (!currentQuestion) {
    return (
      <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
        <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} text-lg mb-4`}>
          Nenhuma questão de residência disponível para quiz.
        </p>
        <button
          onClick={onBack}
          className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Voltar para a tela anterior"
        >
          Voltar
        </button>
      </section>
    );
  }

  return (
    <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>
        {quizName || 'Quiz de Residência'} ({currentQuestionIndex + 1}/{quizQuestions.length})
      </h2>

      <div className={`p-8 rounded-xl shadow-lg ${darkMode ? 'bg-gray-800 border border-gray-600' : 'bg-white border border-gray-100'} min-h-[300px] flex flex-col justify-between`}>
        <p className={`text-xl font-semibold mb-4 ${darkMode ? 'text-indigo-200' : 'text-indigo-700'}`}>{currentQuestion.question}</p>
        <div className="mb-4 text-left space-y-2">
          {currentQuestion.alternatives.map((alt, index) => {
            const isCorrect = index === currentQuestion.correctAnswerIndex;
            const isSelected = index === selectedAnswerIndex;
            let textColorClass = darkMode ? 'text-gray-300' : 'text-gray-700';
            let borderColorClass = '';

            // Define classes de cor e borda com base no resultado e seleção
            if (showResult) {
              if (isCorrect) {
                textColorClass = 'text-green-600 font-bold';
                borderColorClass = 'border-green-500';
              } else if (isSelected && !isCorrect) {
                textColorClass = 'text-red-600 font-bold';
                borderColorClass = 'border-red-500';
              }
            } else if (isSelected) {
              borderColorClass = 'border-indigo-500'; // Destaca a seleção antes de verificar
            }

            return (
              <div
                key={index}
                className={`flex items-center p-2 rounded-lg border-2 ${borderColorClass} ${darkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-50'} transition-all duration-200 cursor-pointer`}
                onClick={() => handleAnswerSelection(index)}
                role="radio"
                aria-checked={isSelected}
                tabIndex={showResult ? -1 : 0} // Desabilita navegação por teclado após mostrar resultado
              >
                <input
                  type="radio"
                  name="quizAnswer"
                  checked={isSelected}
                  onChange={() => handleAnswerSelection(index)}
                  disabled={showResult} // Desabilita seleção após mostrar resultado
                  className="form-radio text-indigo-600 mr-2"
                  aria-hidden="true" // Esconde o input radio visualmente, pois o div pai já é interativo
                />
                <label className={`${textColorClass} cursor-pointer`}>
                  {String.fromCharCode(65 + index)}. {alt.text}
                </label>
              </div>
            );
          })}
        </div>

        {/* Botão para verificar resposta (visível apenas antes de mostrar o resultado) */}
        {!showResult && (
          <button
            onClick={handleSubmitAnswer}
            className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md mt-4"
            disabled={selectedAnswerIndex === null} // Desabilita se nenhuma resposta selecionada
            aria-label="Verificar resposta"
          >
            Verificar Resposta
          </button>
        )}

        {/* Seção de resultado e comentário (visível após verificar a resposta) */}
        {showResult && (
          <div className="mt-4">
            {selectedAnswerIndex === currentQuestion.correctAnswerIndex ? (
              <p className="text-green-600 font-bold text-lg">Correto!</p>
            ) : (
              <p className="text-red-600 font-bold text-lg">Incorreto. A resposta correta é {String.fromCharCode(65 + currentQuestion.correctAnswerIndex)}.</p>
            )}

            {currentQuestion.comment && (
              <button
                onClick={() => setShowComment(!showComment)}
                className={`mt-4 text-sm font-medium ${darkMode ? 'text-gray-200' : 'text-gray-700'} hover:text-indigo-600 transition-colors flex items-center justify-center mx-auto`}
                aria-label={showComment ? 'Ocultar comentário' : 'Visualizar comentário'}
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
                </svg>
                {showComment ? 'Ocultar Comentário' : 'Visualizar Comentário'}
              </button>
            )}
            {showComment && currentQuestion.comment && (
              <div className={`mt-2 p-3 rounded-lg text-left ${darkMode ? 'bg-gray-700 text-gray-200' : 'bg-gray-100 text-gray-800'}`}>
                <p className="font-medium">Comentário:</p>
                <p>{currentQuestion.comment}</p>
              </div>
            )}

            <button
              onClick={handleNextQuestion}
              className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md mt-4"
              disabled={answeredQuestionsCount <= currentQuestionIndex} // Desabilita se não respondido
              aria-label={currentQuestionIndex === quizQuestions.length - 1 ? 'Concluir quiz' : 'Próxima questão'}
            >
              {currentQuestionIndex === quizQuestions.length - 1 ? 'Concluir Quiz' : 'Próxima Questão'}
            </button>
          </div>
        )}
      </div>
      <button
        onClick={onBack}
        className="mt-6 bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
        aria-label="Voltar para a tela anterior"
      >
        Voltar
      </button>
    </section>
  );
}

/**
 * Componente para importar e exportar flashcards em formato JSON.
 * @param {object} props - As props do componente.
 * @param {Array<object>} props.flashcards - Lista de flashcards para exportar.
 * @param {function} props.onImport - Função de callback para importar flashcards.
 * @param {function} props.onBack - Função para voltar à tela anterior.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 * @param {Array<string>} props.disciplines - Lista de disciplinas existentes para o dropdown.
 */
function ImportExport({ flashcards, onImport, onBack, darkMode, disciplines }) {
  const fileInputRef = useRef(null);
  const [selectedFile, setSelectedFile] = useState(null);
  const [importedFileContent, setImportedFileContent] = useState('');
  const [importMessage, setImportMessage] = useState('');
  const [importDiscipline, setImportDiscipline] = useState(''); // New state for discipline
  const [showNewImportDisciplineInput, setShowNewImportDisciplineInput] = useState(false); // For new discipline input

  /**
   * Lida com a exportação dos flashcards para um arquivo JSON.
   */
  const handleExport = () => {
    const dataStr = JSON.stringify(flashcards, null, 2); // Formata o JSON com indentação
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
    const exportFileDefaultName = 'flashcards.json';
    let linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click(); // Simula um clique para download
    setImportMessage('Flashcards exportados com sucesso!');
  };

  /**
   * Função para analisar o conteúdo de um arquivo CSV.
   * Espera o formato: Pergunta,Resposta,Disciplina
   * @param {string} csvString - O conteúdo bruto do arquivo CSV.
   * @returns {Array<object>} Um array de objetos flashcard.
   * @throws {Error} Se o CSV estiver vazio ou mal formatado.
   */
  const parseCsvContent = (csvString) => {
    const lines = csvString.split('\n').filter(line => line.trim() !== ''); // Filtra linhas vazias
    if (lines.length === 0) {
      throw new Error("O arquivo CSV está vazio ou contém apenas linhas em branco.");
    }

    const parsedFlashcards = [];
    lines.forEach((line, index) => {
      // Ignora linhas que parecem ser apenas um cabeçalho (ex: se a primeira linha for "Pergunta,Resposta,Disciplina")
      if (index === 0 && line.toLowerCase().startsWith('pergunta,resposta')) {
        return; // Pula a linha do cabeçalho
      }

      const parts = line.split(','); 
      
      if (parts.length >= 2) { // Pelo menos pergunta e resposta
        const question = parts[0] ? parts[0].trim() : '';
        const answer = parts[1] ? parts[1].trim() : '';
        const discipline = parts[2] ? parts[2].trim() : null; // Disciplina é opcional

        if (question && answer) { // Garante que pergunta e resposta não estão vazias
          parsedFlashcards.push({
            question,
            answer,
            discipline,
            type: 'simple' // CSVs importados serão flashcards simples
          });
        }
      }
    });
    return parsedFlashcards;
  };

  /**
   * Lida com a seleção de um arquivo pelo input.
   * @param {Event} e - O evento de mudança do input de arquivo.
   */
  const handleFileSelect = (e) => {
    const file = e.target.files[0];
    if (file) {
      setSelectedFile(file);
      setImportMessage(''); // Limpa mensagens anteriores
      const reader = new FileReader();
      reader.onload = (event) => {
        setImportedFileContent(event.target.result);
      };
      reader.onerror = () => {
        setImportMessage('Erro ao ler o arquivo.');
        setImportedFileContent('');
      };
      reader.readAsText(file);
    } else {
      setSelectedFile(null);
      setImportedFileContent('');
      setImportMessage('');
    }
  };

  /**
   * Lida com a importação de flashcards a partir do conteúdo do arquivo selecionado.
   * Tenta parsear o JSON ou CSV e adicionar os cards.
   */
  const handleImportProcess = () => {
    if (!importedFileContent) {
      setImportMessage('Nenhum arquivo carregado para importar.');
      return;
    }

    try {
      let importedCards = [];
      const fileName = selectedFile.name.toLowerCase();

      if (fileName.endsWith('.json')) {
        importedCards = JSON.parse(importedFileContent);
        if (!Array.isArray(importedCards)) {
          throw new Error('O conteúdo do arquivo JSON não é um array de flashcards válido.');
        }
      } else if (fileName.endsWith('.csv')) {
        importedCards = parseCsvContent(importedFileContent);
        if (importedCards.length === 0) {
          throw new Error('Nenhum flashcard válido encontrado no arquivo CSV. Verifique o formato (Pergunta,Resposta,Disciplina).');
        }
      } else if (fileName.endsWith('.apkg')) {
          setImportMessage('Erro ao importar arquivo .apkg: Arquivos .apkg são pacotes binários do Anki e não podem ser lidos diretamente como JSON ou CSV. Por favor, exporte seu deck do Anki como um arquivo JSON ou CSV e tente importar novamente.');
          return; // Sai da função para .apkg
      } else {
        setImportMessage('Formato de arquivo não suportado. Por favor, selecione um arquivo .json ou .csv.');
        return;
      }

      // Aplica a disciplina inserida manualmente, sobrescrevendo a do arquivo se existir
      const finalImportedCards = importedCards.map(card => {
        const newCard = { ...card };
        if (importDiscipline.trim() !== '' && importDiscipline !== 'new-discipline') {
          newCard.discipline = importDiscipline.trim();
        } else if (showNewImportDisciplineInput && importDiscipline.trim() !== '') {
          newCard.discipline = importDiscipline.trim(); // Use the new discipline name
        }
        return newCard;
      });

      finalImportedCards.forEach(card => onImport(card)); // Chama onImport para cada card
      setImportMessage(`Importação bem-sucedida! ${finalImportedCards.length} flashcards importados.`);
      setSelectedFile(null);
      setImportedFileContent('');
      setImportDiscipline(''); // Limpa o campo de disciplina
      setShowNewImportDisciplineInput(false); // Reset new discipline input visibility
      if (fileInputRef.current) {
        fileInputRef.current.value = ""; // Limpa o input de arquivo
      }
    } catch (e) {
      setImportMessage(`Erro ao analisar o arquivo: ${e.message}. Certifique-se de que o arquivo está no formato correto.`);
      console.error("ImportExport - Erro ao parsear arquivo para importação: ", e);
    }
  };

  return (
    <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>Importar/Exportar Flashcards</h2>

      {/* Mensagem de feedback */}
      {importMessage && (
        <div className={`mb-4 p-3 rounded-lg ${importMessage.includes('Erro') ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'} border ${importMessage.includes('Erro') ? 'border-red-400' : 'border-green-400'}`}>
          {importMessage}
        </div>
      )}

      {/* Seção de Exportação */}
      <div className="mb-6 p-4 border rounded-lg ${darkMode ? 'border-gray-600 bg-gray-800' : 'border-gray-200 bg-white'}">
        <h3 className={`text-xl font-semibold mb-4 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Exportar Flashcards</h3>
        <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} mb-4`}>
          Exporte todos os seus flashcards para um arquivo JSON.
        </p>
        <button
          onClick={handleExport}
          className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Exportar flashcards para JSON"
        >
          Exportar para JSON
        </button>
      </div>

      {/* Seção de Importação */}
      <div className="p-4 border rounded-lg ${darkMode ? 'border-gray-600 bg-gray-800' : 'border-gray-200 bg-white'}">
        <h3 className={`text-xl font-semibold mb-4 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Importar Flashcards</h3>
        <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} mb-4`}>
          Selecione um arquivo `.json` ou `.csv` para importar seus flashcards.
        </p>
        <div className={`mb-4 p-3 rounded-lg ${darkMode ? 'bg-yellow-900 border-yellow-700 text-yellow-300' : 'bg-yellow-100 border-yellow-400 text-yellow-700'}`}>
          <p className="font-semibold mb-2">Atenção ao importar arquivos .apkg:</p>
          <p>
            Arquivos `.apkg` são pacotes binários do Anki e não podem ser lidos diretamente.
            Para importar seu deck do Anki, você precisa exportá-lo do Anki como um arquivo de texto (ex: JSON ou CSV) primeiro.
          </p>
          <p className="font-semibold mt-4 mb-2">Formato esperado para arquivos .csv:</p>
          <p>
            Para arquivos `.csv`, o formato esperado é: <code>Pergunta,Resposta,Disciplina</code>.
            Cada linha deve conter uma pergunta, uma resposta e opcionalmente uma disciplina, separados por vírgulas.
          </p>
        </div>
        <input
          type="file"
          ref={fileInputRef}
          accept=".json,.csv,.apkg"
          onChange={handleFileSelect}
          className={`w-full p-3 border rounded-lg ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'border-gray-300 text-gray-800'}`}
          aria-label="Selecionar arquivo para importação"
        />

        {/* Campo de entrada para Disciplina */}
        <div className="mt-4 space-y-4">
          <div>
            <label htmlFor="importDiscipline" className={`block text-sm font-medium mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>
              Disciplina (opcional, será aplicada a todos os flashcards importados)
            </label>
            <select
              id="importDiscipline"
              value={importDiscipline}
              onChange={(e) => {
                setImportDiscipline(e.target.value);
                setShowNewImportDisciplineInput(e.target.value === 'new-discipline');
              }}
              className={`w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
              aria-label="Disciplina para flashcards importados"
            >
              <option value="">Manter do arquivo / Sem disciplina</option>
              {disciplines.map(disc => (
                <option key={disc} value={disc}>{disc}</option>
              ))}
              <option value="new-discipline">Criar Nova Disciplina</option>
            </select>
            {showNewImportDisciplineInput && (
              <input
                type="text"
                placeholder="Nome da nova disciplina"
                value={importDiscipline} // Use importDiscipline for the new name
                onChange={(e) => setImportDiscipline(e.target.value)}
                className={`mt-2 w-full p-3 border rounded-lg focus:ring-2 focus:ring-indigo-500 ${darkMode ? 'bg-gray-600 border-gray-500 text-gray-100 placeholder-gray-400' : 'border-gray-300 text-gray-800 placeholder-gray-500'}`}
                required={showNewImportDisciplineInput}
                aria-label="Campo para digitar o nome da nova disciplina para importação"
              />
            )}
          </div>
        </div>

        {selectedFile && (
          <div className="mt-4 text-left">
            <p className={`font-semibold ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>
              Arquivo selecionado: <span className="font-normal">{selectedFile.name}</span>
            </p>
            <p className={`text-sm ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>
              Tamanho: {(selectedFile.size / 1024).toFixed(2)} KB
            </p>
            <div className={`mt-2 p-3 rounded-lg border ${darkMode ? 'bg-gray-700 border-gray-600 text-gray-300' : 'bg-gray-100 border-gray-300 text-gray-800'} overflow-auto max-h-40`}>
              <h4 className={`font-semibold mb-1 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Pré-visualização do Conteúdo:</h4>
              <pre className="text-xs whitespace-pre-wrap break-all">{importedFileContent.substring(0, 500)}...</pre>
            </div>
            <button
              onClick={handleImportProcess}
              className="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
              aria-label="Processar importação do arquivo selecionado"
            >
              Processar Importação
            </button>
          </div>
        )}
      </div>

      <button
        onClick={onBack}
        className="mt-6 bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
        aria-label="Voltar para a tela anterior"
      >
        Voltar
      </button>
    </section>
  );
}

/**
 * Componente para compartilhar flashcards publicamente e importar flashcards públicos.
 * @param {object} props - As props do componente.
 * @param {string} props.userId - ID do usuário atual.
 * @param {object} props.db - Instância do Firestore.
 * @param {string} props.appId - ID da aplicação.
 * @param {function} props.onBack - Função para voltar à tela anterior.
 * @param {function} props.setMessage - Função para exibir mensagens de sucesso.
 * @param {function} props.setError - Função para exibir mensagens de erro.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 */
function ShareFlashcards({ userId, db, appId, onBack, setMessage, setError, darkMode }) {
  const [publicFlashcards, setPublicFlashcards] = useState([]);

  /**
   * Callback memoizado para buscar flashcards públicos do Firestore.
   */
  const fetchPublicFlashcards = useCallback(async () => {
    if (!db) return;
    try {
      const publicCollectionRef = collection(db, `artifacts/${appId}/public/data/flashcards`);
      // Filtra para trazer apenas flashcards do tipo 'simple' para esta seção de compartilhamento
      // Questões de residência já são gerenciadas separadamente
      const q = query(publicCollectionRef, where('type', '==', 'simple'));
      const querySnapshot = await getDocs(q);
      const fetchedCards = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setPublicFlashcards(fetchedCards);
      setMessage('Flashcards públicos carregados.');
    } catch (e) {
      console.error("ShareFlashcards - Erro ao buscar flashcards públicos: ", e);
      setError("Erro ao carregar flashcards públicos: " + e.message);
    }
  }, [db, appId, setMessage, setError]);

  // Hook para carregar flashcards públicos ao montar o componente
  useEffect(() => {
    fetchPublicFlashcards();
  }, [fetchPublicFlashcards]);

  /**
   * Lida com o compartilhamento dos flashcards privados do usuário para a coleção pública.
   */
  const handleShareToPublic = async () => {
    if (!db || !userId) {
      setError('Usuário não autenticado ou Firestore não disponível.');
      return;
    }
    try {
      const userFlashcardsRef = collection(db, `artifacts/${appId}/users/${userId}/flashcards`);
      const publicFlashcardsRef = collection(db, `artifacts/${appId}/public/data/flashcards`);
      const userSnapshot = await getDocs(userFlashcardsRef);

      // Adiciona cada flashcard do usuário à coleção pública
      for (const docSnapshot of userSnapshot.docs) {
        const flashcardData = docSnapshot.data();
        // Garante que apenas flashcards do tipo 'simple' sejam compartilhados aqui
        if (flashcardData.type === 'simple') {
          await addDoc(publicFlashcardsRef, { ...flashcardData, ownerId: userId, sharedAt: serverTimestamp() });
        }
      }
      setMessage('Seus flashcards foram compartilhados publicamente!');
      fetchPublicFlashcards(); // Recarrega a lista de flashcards públicos
    } catch (e) {
      console.error("ShareFlashcards - Erro ao compartilhar publicamente: ", e);
      setError("Erro ao compartilhar publicamente: " + e.message);
    }
  };

  /**
   * Lida com a importação de um flashcard público para a coleção privada do usuário.
   * Verifica se o flashcard já existe para evitar duplicatas.
   * @param {object} card - O flashcard público a ser importado.
   */
  const handleImportPublicFlashcard = async (card) => {
    if (!db || !userId) {
      setError('Usuário não autenticado ou Firestore não disponível.');
      return;
    }
    try {
      const userFlashcardsRef = collection(db, `artifacts/${appId}/users/${userId}/flashcards`);
      // Verifica se um flashcard com a mesma pergunta e resposta já existe
      const existingCardQuery = query(userFlashcardsRef, where('question', '==', card.question), where('answer', '==', card.answer));
      const existingSnapshot = await getDocs(existingCardQuery);

      if (existingSnapshot.empty) {
        // Adiciona o flashcard à coleção privada do usuário
        await addDoc(userFlashcardsRef, {
          question: card.question,
          answer: card.answer,
          discipline: card.discipline || 'Importado',
          createdAt: serverTimestamp(),
          lastReviewedAt: null,
          nextReviewAt: null,
          reviewCount: 0,
          easeFactor: 2.5,
          interval: 0,
          originalOwnerId: card.ownerId || 'unknown', // Mantém o ID do criador original
          type: 'simple' // Garante que o tipo é simples ao importar
        });
        setMessage(`Flashcard "${card.question}" importado com sucesso!`);
      } else {
        setMessage(`Flashcard "${card.question}" já existe em sua coleção.`);
      }
    } catch (e) {
      console.error("ShareFlashcards - Erro ao importar flashcard público: ", e);
      setError("Erro ao importar flashcard público: " + e.message);
    }
  };

  return (
    <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>Compartilhar Flashcards</h2>

      {/* Seção para compartilhar flashcards do usuário publicamente */}
      <div className="mb-8 p-4 border rounded-lg ${darkMode ? 'border-gray-600 bg-gray-800' : 'border-gray-200 bg-white'}">
        <h3 className={`text-xl font-semibold mb-4 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Compartilhar Meus Flashcards Publicamente</h3>
        <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} mb-4`}>
          Torne todos os seus flashcards visíveis e importáveis por outros usuários.
        </p>
        <button
          onClick={handleShareToPublic}
          className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
          aria-label="Compartilhar todos os meus flashcards publicamente"
        >
          Compartilhar Publicamente
        </button>
      </div>

      {/* Seção para importar flashcards públicos */}
      <div className="mb-8 p-4 border rounded-lg ${darkMode ? 'border-gray-600 bg-gray-800' : 'border-gray-200 bg-white'}">
        <h3 className={`text-xl font-semibold mb-4 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>Importar Flashcards Públicos</h3>
        {publicFlashcards.length === 0 ? (
          <p className={`${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>Nenhum flashcard público disponível para importação.</p>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {publicFlashcards.map(card => (
              <div key={card.id} className={`p-4 rounded-lg shadow-md ${darkMode ? 'bg-gray-800 border border-gray-600' : 'bg-white border border-gray-100'}`}>
                <p className={`font-semibold ${darkMode ? 'text-indigo-200' : 'text-indigo-700'}`}>{card.question}</p>
                <p className={`${darkMode ? 'text-gray-300' : 'text-gray-700'} text-sm mb-2`}>{card.answer}</p>
                <p className={`text-xs ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>Disciplina: {card.discipline || 'N/A'}</p>
                <p className={`text-xs ${darkMode ? 'text-gray-400' : 'text-gray-500'}`}>Criador: {card.ownerId || 'Desconhecido'}</p>
                <button
                  onClick={() => handleImportPublicFlashcard(card)}
                  className="mt-3 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-300 ease-in-out"
                  aria-label={`Importar flashcard ${card.question}`}
                >
                  Importar
                </button>
              </div>
            ))}
          </div>
        )}
      </div>

      <button
        onClick={onBack}
        className="mt-6 bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
        aria-label="Voltar para a tela anterior"
      >
        Voltar
      </button>
    </section>
  );
}

/**
 * Componente para exibir estatísticas de revisão de flashcards por disciplina.
 * Utiliza um gráfico de pizza para visualizar a distribuição de "Fácil", "Difícil" e "Esqueci".
 * @param {object} props - As props do componente.
 * @param {Array<object>} props.flashcards - Lista de flashcards com dados de revisão.
 * @param {Array<string>} props.disciplines - Lista de disciplinas disponíveis.
 * @param {function} props.onBack - Função para voltar à tela anterior.
 * @param {boolean} props.darkMode - Indica se o modo escuro está ativo.
 */
function Statistics({ flashcards, disciplines, onBack, darkMode }) {
  // Cores para o gráfico de pizza (Fácil, Difícil, Esqueci)
  const COLORS = ['#4CAF50', '#FFC107', '#F44336']; // Green (Easy), Yellow (Difficult), Red (Forgotten)

  /**
   * Calcula as estatísticas de revisão por disciplina, memoizado para performance.
   * Agrupa os dados de 'easy', 'difficult' e 'forgotten' por disciplina.
   */
  const disciplineStats = useMemo(() => {
    const stats = {};
    flashcards.forEach(card => {
      const disc = card.discipline || 'Sem Disciplina'; // Normaliza o nome da disciplina
      if (!stats[disc]) {
        stats[disc] = { easy: 0, difficult: 0, forgotten: 0 };
      }
      if (card.reviewStats) {
        stats[disc].easy += card.reviewStats.easy || 0;
        stats[disc].difficult += card.reviewStats.difficult || 0;
        stats[disc].forgotten += card.reviewStats.forgotten || 0;
      }
    });
    return stats;
  }, [flashcards]);

  return (
    <section className={`p-4 rounded-lg ${darkMode ? 'bg-gray-700' : 'bg-gray-50'} text-center`}>
      <h2 className={`text-3xl font-bold mb-6 ${darkMode ? 'text-indigo-300' : 'text-indigo-700'}`}>Estatísticas de Revisão</h2>

      {Object.keys(disciplineStats).length === 0 ? (
        <p className={`${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
          Nenhum dado de revisão disponível ainda. Comece a revisar seus flashcards!
        </p>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {Object.entries(disciplineStats).map(([disciplineName, data]) => {
            const total = data.easy + data.difficult + data.forgotten;
            if (total === 0) return null; // Não exibe gráficos para disciplinas sem revisões

            // Prepara os dados para o gráfico de pizza, filtrando valores zero
            const chartData = [
              { name: 'Fácil', value: data.easy },
              { name: 'Difícil', value: data.difficult },
              { name: 'Esqueci', value: data.forgotten },
            ].filter(item => item.value > 0);

            return (
              <div key={disciplineName} className={`p-4 rounded-lg shadow-md ${darkMode ? 'bg-gray-800 border border-gray-600' : 'bg-white border border-gray-100'}`}>
                <h3 className={`text-xl font-semibold mb-4 ${darkMode ? 'text-indigo-200' : 'text-indigo-700'}`}>{disciplineName}</h3>
                {/* Gráfico de Pizza responsivo */}
                <ResponsiveContainer width="100%" height={200}>
                  <PieChart>
                    <Pie
                      data={chartData}
                      cx="50%"
                      cy="50%"
                      outerRadius={80}
                      fill="#8884d8" // Cor de preenchimento padrão, será sobrescrita pelas Cells
                      dataKey="value"
                      label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                      labelLine={false}
                    >
                      {/* Células do gráfico com cores definidas */}
                      {chartData.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                      ))}
                    </Pie>
                    <Tooltip /> {/* Exibe informações ao passar o mouse */}
                    <Legend /> {/* Legenda do gráfico */}
                  </PieChart>
                </ResponsiveContainer>
              </div>
            );
          })}
        </div>
      )}

      <button
        onClick={onBack}
        className="mt-6 bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 shadow-md"
        aria-label="Voltar para a tela anterior"
      >
        Voltar
      </button>
    </section>
  );
}

export default App;
